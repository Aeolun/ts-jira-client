/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/2/application-properties": {
    /** @description Returns an application property. */
    get: operations["getProperty"];
  };
  "/api/2/application-properties/advanced-settings": {
    /** @description Returns the properties that are displayed on the "General Configuration > Advanced Settings" page. */
    get: operations["getAdvancedSettings"];
  };
  "/api/2/application-properties/{id}": {
    /** @description Modify an application property via PUT. The "value" field present in the PUT will override the existing value. */
    put: operations["setPropertyViaRestfulTable"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/2/applicationrole": {
    /**
     * @description Returns all ApplicationRoles in the system. Will also return an ETag header containing a version hash of the
     *  collection of ApplicationRoles.
     */
    get: operations["getAll"];
    /**
     * @description Updates the ApplicationRoles with the passed data if the version hash is the same as the server.
     *  Only the groups and default groups setting of the role may be updated. Requests to change the key
     *  or the name of the role will be silently ignored. It is acceptable to pass only the roles that are updated
     *  as roles that are present in the server but not in data to update with, will not be deleted.
     */
    put: operations["putBulk"];
  };
  "/api/2/applicationrole/{key}": {
    /** @description Returns the ApplicationRole with passed key if it exists. */
    get: operations["get"];
    /**
     * @description Updates the ApplicationRole with the passed data. Only the groups and default groups setting of the
     *  role may be updated. Requests to change the key or the name of the role will be silently ignored.
     *  <p>
     *  Optional: If versionHash is passed through the If-Match header the request will be rejected if not the
     *  same as server
     */
    put: operations["put"];
    parameters: {
      path: {
        /** @description the key of the role to update. */
        key: string;
      };
    };
  };
  "/api/2/attachment/meta": {
    /**
     * @description Returns the meta information for an attachments, specifically if they are enabled and the maximum upload size
     *  allowed.
     */
    get: operations["getAttachmentMeta"];
  };
  "/api/2/attachment/{id}": {
    /** @description Returns the meta-data for an attachment, including the URI of the actual attached file. */
    get: operations["getAttachment"];
    /** @description Remove an attachment from an issue. */
    delete: operations["removeAttachment"];
    parameters: {
      path: {
        /** @description id of the attachment to remove */
        id: string;
      };
    };
  };
  "/api/2/attachment/{id}/expand/human": {
    /** @description Tries to expand an attachment. Output is human-readable and subject to change. */
    get: operations["expandForHumans"];
    parameters: {
      path: {
        /** @description the id of the attachment to expand. */
        id: string;
      };
    };
  };
  "/api/2/attachment/{id}/expand/raw": {
    /** @description Tries to expand an attachment. Output is raw and should be backwards-compatible through the course of time. */
    get: operations["expandForMachines"];
    parameters: {
      path: {
        /** @description the id of the attachment to expand. */
        id: string;
      };
    };
  };
  "/api/2/auditing/record": {
    /** @description Returns auditing records filtered using provided parameters */
    get: operations["getRecords"];
    /** @description Store a record in audit log */
    post: operations["addRecord"];
  };
  "/api/2/avatar/{type}/system": {
    /** @description Returns all system avatars of the given type. */
    get: operations["getAllSystemAvatars"];
    parameters: {
      path: {
        /** @description the avatar type */
        type: string;
      };
    };
  };
  "/api/2/avatar/{type}/temporary": {
    /** @description Creates temporary avatar */
    post: operations["storeTemporaryAvatar"];
    parameters: {
      path: {
        /** @description the avatar type */
        type: string;
      };
    };
  };
  "/api/2/avatar/{type}/temporaryCrop": {
    /** @description Updates the cropping instructions of the temporary avatar. */
    post: operations["createAvatarFromTemporary"];
    parameters: {
      path: {
        /** @description the avatar type */
        type: string;
      };
    };
  };
  "/api/2/cluster/index-snapshot/{nodeId}": {
    /** @description request current index from node (the request is processed asynchronously) */
    put: operations["requestCurrentIndexFromNode"];
    parameters: {
      path: {
        nodeId: string;
      };
    };
  };
  "/api/2/cluster/node/{nodeId}": {
    /** @description Delete the node from the cluster if state of node is OFFLINE. */
    delete: operations["deleteNode"];
    parameters: {
      path: {
        nodeId: string;
      };
    };
  };
  "/api/2/cluster/node/{nodeId}/offline": {
    /**
     * @description Change the node's state to offline if the node is reporting as active, but is not alive.
     *  Don't use this method as an equivalent of running ./stop-jira.sh. This method doesn't shut down
     *  a node, but only changes its state, so that other nodes don't communicate with it.
     */
    put: operations["changeNodeStateToOffline"];
    parameters: {
      path: {
        nodeId: string;
      };
    };
  };
  "/api/2/cluster/nodes": {
    get: operations["getAllNodes"];
  };
  "/api/2/cluster/zdu/approve": {
    post: operations["approveUpgrade"];
  };
  "/api/2/cluster/zdu/cancel": {
    post: operations["cancelUpgrade"];
  };
  "/api/2/cluster/zdu/retryUpgrade": {
    post: operations["acknowledgeErrors"];
  };
  "/api/2/cluster/zdu/start": {
    post: operations["setReadyToUpgrade"];
  };
  "/api/2/cluster/zdu/state": {
    get: operations["getState"];
  };
  "/api/2/comment/{commentId}/properties": {
    /** @description Returns the keys of all properties for the comment identified by the key or by the id. */
    get: operations["getPropertiesKeys"];
    parameters: {
      path: {
        /** @description the comment from which keys will be returned. */
        commentId: string;
      };
    };
  };
  "/api/2/comment/{commentId}/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the comment identified by the key or by the id. The user who retrieves
     *  the property is required to have permissions to read the comment.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified comment's property.
     *  <p>
     *  You can use this resource to store a custom data against the comment identified by the key or by the id. The user
     *  who stores the data is required to have permissions to administer the comment.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the comment identified by the key or by the id. Ths user removing the property is required
     *  to have permissions to administer the comment.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the comment from which keys will be returned. */
        commentId: string;
        /** @description the key of the property to return. */
        propertyKey: string;
      };
    };
  };
  "/api/2/component": {
    /** @description Create a component via POST. */
    post: operations["createComponent"];
  };
  "/api/2/component/page": {
    /** @description Returns paginated list of filtered active components */
    get: operations["getPaginatedComponents"];
  };
  "/api/2/component/{id}": {
    /** @description Returns a project component. */
    get: operations["getComponent"];
    /**
     * @description Modify a component via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
     *  is not present, it is silently ignored.
     *  <p>
     *  If leadUserName is an empty string ("") the component lead will be removed.
     */
    put: operations["updateComponent"];
    /** @description Delete a project component. */
    delete: operations["delete"];
    parameters: {
      path: {
        /** @description The component to delete. */
        id: string;
      };
    };
  };
  "/api/2/component/{id}/relatedIssueCounts": {
    /** @description Returns counts of issues related to this component. */
    get: operations["getComponentRelatedIssues"];
    parameters: {
      path: {
        /** @description a String containing the component id */
        id: string;
      };
    };
  };
  "/api/2/configuration": {
    /**
     * @description Returns the information if the optional features in Jira are enabled or disabled. If the time tracking is enabled,
     *  it also returns the detailed information about time tracking configuration.
     */
    get: operations["getConfiguration"];
  };
  "/api/2/customFieldOption/{id}": {
    /** @description Returns a full representation of the Custom Field Option that has the given id. */
    get: operations["getCustomFieldOption"];
    parameters: {
      path: {
        /** @description a String containing an Custom Field Option id */
        id: string;
      };
    };
  };
  "/api/2/customFields": {
    get: operations["getCustomFields"];
    delete: operations["bulkDeleteCustomFields"];
  };
  "/api/2/customFields/{customFieldId}/options": {
    /**
     * @description Returns custom field's options defined in a given context composed of projects and issue types.
     *  <p>
     *  If the projects and issue types match more than one context or the context for such a combination does not exist then no options are returned.
     */
    get: operations["getCustomFieldOptions"];
    parameters: {
      path: {
        /** @description id of a custom field. */
        customFieldId: number;
      };
    };
  };
  "/api/2/dashboard": {
    /** @description Returns a list of all dashboards, optionally filtering them. */
    get: operations["list"];
  };
  "/api/2/dashboard/{dashboardId}/items/{itemId}/properties": {
    /** @description Returns the keys of all properties for the dashboard item identified by the id. */
    get: operations["getPropertiesKeys"];
    parameters: {
      path: {
        /** @description the dashboard item from which keys will be returned. */
        itemId: string;
        dashboardId: string;
      };
    };
  };
  "/api/2/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the dashboard item identified by the id.
     *  The user who retrieves the property is required to have permissions to read the dashboard item.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified dashboard item's property.
     *  <p>
     *  You can use this resource to store a custom data against the dashboard item identified by the id.
     *  The user who stores the data is required to have permissions to administer the dashboard item.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the dashboard item identified by the key or by the id. Ths user removing the property is required
     *  to have permissions to administer the dashboard item.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the dashboard item from which keys will be returned. */
        itemId: string;
        dashboardId: string;
        /** @description the key of the property to return. */
        propertyKey: string;
      };
    };
  };
  "/api/2/dashboard/{id}": {
    /** @description Returns a single dashboard. */
    get: operations["getDashboard"];
    parameters: {
      path: {
        /** @description the dashboard id */
        id: string;
      };
    };
  };
  "/api/2/email-templates": {
    /** @description Creates a zip file containing email templates at local home and returns the file. */
    get: operations["downloadEmailTemplates"];
    /** @description Extracts given zip file to temporary templates folder. If the folder already exists it will replace it's content */
    post: operations["uploadEmailTemplates"];
  };
  "/api/2/email-templates/apply": {
    /** @description Replaces the current email templates pack with previously uploaded one, if exists. */
    post: operations["applyEmailTemplates"];
  };
  "/api/2/email-templates/revert": {
    /** @description Replaces the current email templates pack with default templates, which are copied over from Jira binaries. */
    post: operations["revertEmailTemplatesToDefault"];
  };
  "/api/2/email-templates/types": {
    /** @description Returns a list of root templates mapped with Event Types. The list can be used to decide which test emails to send. */
    get: operations["getEmailTypes"];
  };
  "/api/2/field": {
    /** @description Returns a list of all fields, both System and Custom */
    get: operations["getFields"];
    /** @description Creates a custom field using a definition (object encapsulating custom field data) */
    post: operations["createCustomField"];
  };
  "/api/2/filter": {
    /**
     * @description Creates a new filter, and returns newly created filter.
     *  Currently sets permissions just using the users default sharing permissions
     */
    post: operations["createFilter"];
  };
  "/api/2/filter/defaultShareScope": {
    /** @description Returns the default share scope of the logged-in user. */
    get: operations["getDefaultShareScope"];
    /**
     * @description Sets the default share scope of the logged-in user.
     *  <p>
     *  Available values are: AUTHENTICATED (for sharing with all logged-in users) and PRIVATE (for no shares).
     */
    put: operations["setDefaultShareScope"];
  };
  "/api/2/filter/favourite": {
    /** @description Returns the favourite filters of the logged-in user. */
    get: operations["getFavouriteFilters"];
  };
  "/api/2/filter/{id}": {
    /** @description Returns a filter given an id */
    get: operations["getFilter"];
    /**
     * @description Updates an existing filter, and returns its new value.
     *  <p>
     *  The following properties of a filter can be updated: 'jql', 'name', 'description'.
     *  Additionally, administrators can also update the 'owner' field.
     *  To get, set or unset 'favourite', use rest/api/1.0/filters/{id}/favourite with GET, PUT and DELETE methods instead.
     *  </p>
     */
    put: operations["editFilter"];
    /** @description Delete a filter. */
    delete: operations["deleteFilter"];
    parameters: {
      path: {
        /** @description the id of the filter being looked up */
        id: number;
      };
    };
  };
  "/api/2/filter/{id}/columns": {
    /**
     * @description Returns the default columns for the given filter. Currently logged in user will be used as
     *  the user making such request.
     */
    get: operations["defaultColumns"];
    /** @description Sets the default columns for the given filter. */
    put: operations["setColumns"];
    /** @description Resets the columns for the given filter such that the filter no longer has its own column config. */
    delete: operations["resetColumns"];
    parameters: {
      path: {
        /** @description id of the filter */
        id: number;
      };
    };
  };
  "/api/2/filter/{id}/permission": {
    /** @description Returns all share permissions of the given filter. */
    get: operations["getSharePermissions"];
    /** @description Adds a share permissions to the given filter. Adding a global permission removes all previous permissions from the filter. */
    post: operations["addSharePermission"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/api/2/filter/{id}/permission/{permission-id}": {
    /** @description Removes a share permissions from the given filter. */
    delete: operations["deleteSharePermission"];
    parameters: {
      path: {
        id: number;
        "permission-id": number;
      };
    };
  };
  "/api/2/filter/{id}/permission/{permissionId}": {
    /** @description Returns a single share permission of the given filter. */
    get: operations["getSharePermission"];
    parameters: {
      path: {
        permissionId: number;
        id: number;
      };
    };
  };
  "/api/2/group": {
    /**
     * @description Returns REST representation for the requested group. Allows to get list of active users belonging to the
     *  specified group and its subgroups if "users" expand option is provided. You can page through users list by using
     *  indexes in expand param. For example to get users from index 10 to index 15 use "users[10:15]" expand value. This
     *  will return 6 users (if there are at least 16 users in this group). Indexes are 0-based and inclusive.
     *  <p>
     *  This resource is deprecated, please use group/member API instead.
     */
    get: operations["getGroup"];
    /**
     * @description Creates a group by given group parameter
     *  <p>
     *  Returns REST representation for the requested group.
     */
    post: operations["createGroup"];
    /**
     * @description Deletes a group by given group parameter.
     *  <p>
     *  Returns no content
     */
    delete: operations["removeGroup"];
  };
  "/api/2/group/member": {
    /**
     * @description This resource returns a <a href="#pagination">paginated</a> list of users who are members of the specified group and its subgroups.
     *  Users in the page are ordered by user names. User of this resource is required to have sysadmin or admin permissions.
     */
    get: operations["getUsersFromGroup"];
  };
  "/api/2/group/user": {
    /**
     * @description Adds given user to a group.
     *  <p>
     *  Returns the current state of the group.
     */
    post: operations["addUserToGroup"];
    /**
     * @description Removes given user from a group.
     *  <p>
     *  Returns no content
     */
    delete: operations["removeUserFromGroup"];
  };
  "/api/2/groups/picker": {
    /**
     * @description Returns groups with substrings matching a given query. This is mainly for use with
     *  the group picker, so the returned groups contain html to be used as picker suggestions.
     *  The groups are also wrapped in a single response object that also contains a header for
     *  use in the picker, specifically <i>Showing X of Y matching groups</i>.
     *  <p>
     *  The number of groups returned is limited by the system property "jira.ajax.autocomplete.limit"
     *  <p>
     *  The groups will be unique and sorted.
     */
    get: operations["findGroups"];
  };
  "/api/2/groupuserpicker": {
    /**
     * @description Returns a list of users and groups matching query with highlighting. This resource cannot be accessed
     *  anonymously.
     */
    get: operations["findUsersAndGroups"];
  };
  "/api/2/index-snapshot": {
    /**
     * @description Lists available index snapshots absolute paths with timestamps.
     *  <p>
     *  Only System Administrator can request listing index snapshots.
     */
    get: operations["listIndexSnapshot"];
    /**
     * @description Tries to start taking an index snapshot if no other snapshot creation process is in progress.
     *  Performs a cleanup of index snapshots directory so only a limited number of most recent snapshots are persisted.
     *  If another snapshot creation process is in progress, returns 409 without waiting for the other process to complete.
     *  <p>
     *  Only System Administrator can request creation of snapshot. There is no guarantee as to the time after which the snapshot will be available.
     */
    post: operations["createIndexSnapshot"];
  };
  "/api/2/index-snapshot/isRunning": {
    /**
     * @description Answers true if index snapshot creation is currently running.
     *  <p>
     *  Only System Administrator can request current snapshot creation status.
     */
    get: operations["isIndexSnapshotRunning"];
  };
  "/api/2/index/summary": {
    /**
     * @description Summarizes index condition of current node.
     *  <p/>
     *  Returned data consists of:
     *  <ul>
     *  <li><code>nodeId</code> - Node identifier.</li>
     *  <li><code>reportTime</code> - Time of this report creation.</li>
     *  <li><code>issueIndex</code> - Summary of issue index status.</li>
     *  <li><code>replicationQueues</code> - Map of index replication queues, where
     *  keys represent nodes from which replication operations came from.</li>
     *  </ul>
     *  <p/>
     *  <code>issueIndex</code> can contain:
     *  <ul>
     *  <li><code>indexReadable</code> - If <code>false</code> the end point failed to read data from issue index
     *  (check Jira logs for detailed stack trace), otherwise <code>true</code>.
     *  When <code>false</code> other fields of <code>issueIndex</code> can be not visible.</li>
     *  <li><code>countInDatabase</code> - Count of issues found in database.</li>
     *  <li><code>countInIndex</code> - Count of issues found while querying index.</li>
     *  <li><code>lastUpdatedInDatabase</code> - Time of last update of issue found in database.</li>
     *  <li><code>lastUpdatedInIndex</code> - Time of last update of issue found while querying index.</li>
     *  </ul>
     *  <p/>
     *  <code>replicationQueues</code>'s map values can contain:
     *  <ul>
     *  <li><code>lastConsumedOperation</code> - Last executed index replication operation by current node from sending node's queue.</li>
     *  <li><code>lastConsumedOperation.id</code> - Identifier of the operation.</li>
     *  <li><code>lastConsumedOperation.replicationTime</code> - Time when the operation was sent to other nodes.</li>
     *  <li><code>lastOperationInQueue</code> - Last index replication operation in sending node's queue.</li>
     *  <li><code>lastOperationInQueue.id</code> - Identifier of the operation.</li>
     *  <li><code>lastOperationInQueue.replicationTime</code> - Time when the operation was sent to other nodes.</li>
     *  <li><code>queueSize</code> - Number of operations in queue from sending node to current node.</li>
     *  </ul>
     */
    get: operations["getIndexSummary"];
  };
  "/api/2/issue": {
    /**
     * @description Creates an issue or a sub-task from a JSON representation.
     *  <p/>
     *  The fields that can be set on create, in either the fields parameter or the update parameter can be determined
     *  using the <b>/rest/api/2/issue/createmeta</b> resource.
     *  If a field is not configured to appear on the create screen, then it will not be in the createmeta, and a field
     *  validation error will occur if it is submitted.
     *  <p/>
     *  Creating a sub-task is similar to creating a regular issue, with two important differences:
     *  <ul>
     *  <li>the <code>issueType</code> field must correspond to a sub-task issue type (you can use
     *  <code>/issue/createmeta</code> to discover sub-task issue types), and</li>
     *  <li>you must provide a <code>parent</code> field in the issue create request containing the id or key of the
     *  parent issue.</li>
     *  <li>The <code>updateHistory</code> param adds the project that this issue is created in, to the current user's project history,
     *  if set to true (by default, the project history is not updated).</li>
     *  <li>You can view the project history in the Jira application, via the Projects dropdown.</li>
     *  </ul>
     */
    post: operations["createIssue"];
  };
  "/api/2/issue/archive": {
    /** @description Archives a list of issues. */
    post: operations["archiveIssues"];
  };
  "/api/2/issue/bulk": {
    /**
     * @description Creates issues or sub-tasks from a JSON representation.
     *  <p/>
     *  Creates many issues in one bulk operation.
     *  <p/>
     *  Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:
     *  {@link IssueResource#createIssue(boolean, IssueUpdateBean)}}}
     */
    post: operations["createIssues"];
  };
  "/api/2/issue/createmeta/{projectIdOrKey}/issuetypes": {
    /**
     * @description Returns the metadata for issue types used for creating issues.
     *  Data will not be returned if the user does not have permission to create issues in that project.
     */
    get: operations["getCreateIssueMetaProjectIssueTypes"];
    parameters: {
      path: {
        /** @description to get metadata for */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}": {
    /**
     * @description Returns the metadata for issue types used for creating issues.
     *  Data will not be returned if the user does not have permission to create issues in that project.
     */
    get: operations["getCreateIssueMetaFields"];
    parameters: {
      path: {
        /** @description to get metadata for */
        issueTypeId: string;
        /** @description to get metadata for */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/issue/picker": {
    /**
     * @description Returns suggested issues which match the auto-completion query for the user which executes this request. This REST
     *  method will check the user's history and the user's browsing context and select this issues, which match the query.
     */
    get: operations["getIssuePickerResource"];
  };
  "/api/2/issue/{issueIdOrKey}": {
    /**
     * @description Returns a full representation of the issue for the given issue key.
     *  <p>
     *  An issue JSON consists of the issue key, a collection of fields,
     *  a link to the workflow transition sub-resource, and (optionally) the HTML rendered values of any fields that support it
     *  (e.g. if wiki syntax is enabled for the description or comments).
     *  <p>
     *  The <code>fields</code> param (which can be specified multiple times) gives a comma-separated list of fields
     *  to include in the response. This can be used to retrieve a subset of fields.
     *  A particular field can be excluded by prefixing it with a minus.
     *  <p>
     *  By default, all (<code>*all</code>) fields are returned in this get-issue resource. Note: the default is different
     *  when doing a jql search -- the default there is just navigable fields (<code>*navigable</code>).
     *  <ul>
     *  <li><code>*all</code> - include all fields</li>
     *  <li><code>*navigable</code> - include just navigable fields</li>
     *  <li><code>summary,comment</code> - include just the summary and comments</li>
     *  <li><code>-comment</code> - include everything except comments (the default is <code>*all</code> for get-issue)</li>
     *  <li><code>*all,-comment</code> - include everything except comments</li>
     *  </ul>
     *  <p>
     *  The {@code properties} param is similar to {@code fields} and specifies a comma-separated list of issue
     *  properties to include. Unlike {@code fields}, properties are not included by default. To include them all
     *  send {@code ?properties=*all}. You can also include only specified properties or exclude some properties
     *  with a minus (-) sign.
     *  <p>
     *  <ul>
     *  <li>{@code *all} - include all properties</li>
     *  <li>{@code *all, -prop1} - include all properties except {@code prop1} </li>
     *  <li>{@code prop1, prop1} - include {@code prop1} and {@code prop2} properties </li>
     *  </ul>
     *  </p>
     *  <p/>
     *  Jira will attempt to identify the issue by the <code>issueIdOrKey</code> path parameter. This can be an issue id,
     *  or an issue key. If the issue cannot be found via an exact match, Jira will also look for the issue in a case-insensitive way, or
     *  by looking to see if the issue was moved. In either of these cases, the request will proceed as normal (a 302 or other redirect
     *  will <b>not</b> be returned). The issue key contained in the response will indicate the current value of issue's key.
     *  <p/>
     *  The <code>expand</code> param is used to include, hidden by default, parts of response. This can be used to include:
     *  <ul>
     *  <li><code>renderedFields</code> - field values in HTML format</li>
     *  <li><code>names</code> - display name of each field</li>
     *  <li><code>schema</code> - schema for each field which describes a type of the field</li>
     *  <li><code>transitions</code> - all possible transitions for the given issue</li>
     *  <li><code>operations</code> - all possibles operations which may be applied on issue</li>
     *  <li><code>editmeta</code> - information about how each field may be edited. It contains field's schema as well.</li>
     *  <li><code>changelog</code> - history of all changes of the given issue</li>
     *  <li><code>versionedRepresentations</code> -
     *  REST representations of all fields. Some field may contain more recent versions. RESET representations are numbered.
     *  The greatest number always represents the most recent version. It is recommended that the most recent version is used.
     *  version for these fields which provide a more recent REST representation.
     *  After including <code>versionedRepresentations</code> "fields" field become hidden.</li>
     *  </ul>
     */
    get: operations["getIssue"];
    /**
     * @description Edits an issue from a JSON representation.
     *  <p/>
     *  The issue can either be updated by setting explicit the field value(s)
     *  or by using an operation to change the field value.
     *  <p/>
     *  The fields that can be updated, in either the fields parameter or the update parameter, can be determined
     *  using the <b>/rest/api/2/issue/{issueIdOrKey}/editmeta</b> resource.<br>
     *  If a field is not configured to appear on the edit screen, then it will not be in the editmeta, and a field
     *  validation error will occur if it is submitted.
     *  <p/>
     *  Specifying a "field_id": field_value in the "fields" is a shorthand for a "set" operation in the "update" section.<br>
     *  Field should appear either in "fields" or "update", not in both.
     */
    put: operations["editIssue"];
    /**
     * @description Delete an issue.
     *  <p/>
     *  If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue.
     *  You cannot delete an issue without its subtasks also being deleted.
     */
    delete: operations["deleteIssue"];
    parameters: {
      path: {
        /** @description the issue id or key to update (i.e. JRA-1330) */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/archive": {
    /** @description Archives an issue. */
    put: operations["archiveIssue"];
    parameters: {
      path: {
        /** @description Issue id or issue key */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/assignee": {
    /**
     * @description Assigns an issue to a user.
     *  You can use this resource to assign issues when the user submitting the request has the assign permission but not the
     *  edit issue permission.
     *  If the name is "-1" automatic assignee is used.  A null name will remove the assignee.
     */
    put: operations["assign"];
    parameters: {
      path: {
        /** @description a String containing an issue key */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/attachments": {
    /**
     * @description Add one or more attachments to an issue.
     *  <p>
     *  This resource expects a multipart post. The media-type multipart/form-data is defined in RFC 1867. Most client
     *  libraries have classes that make dealing with multipart posts simple. For instance, in Java the Apache HTTP Components
     *  library provides a
     *  <a href="http://hc.apache.org/httpcomponents-client-ga/httpmime/apidocs/org/apache/http/entity/mime/MultipartEntity.html">MultiPartEntity</a>
     *  that makes it simple to submit a multipart POST.
     *  <p>
     *  In order to protect against XSRF attacks, because this method accepts multipart/form-data, it has XSRF protection
     *  on it.  This means you must submit a header of X-Atlassian-Token: no-check with the request, otherwise it will be
     *  blocked.
     *  <p>
     *  The name of the multipart/form-data parameter that contains attachments must be "file"
     *  <p>
     *  A simple example to upload a file called "myfile.txt" to issue REST-123:
     *  <pre>curl -D- -u admin:admin -X POST -H "X-Atlassian-Token: no-check" -F "file=@myfile.txt" http://myhost/rest/api/2/issue/TEST-123/attachments</pre>
     */
    post: operations["addAttachment"];
    parameters: {
      path: {
        /** @description the issue that you want to add the attachments to */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/comment": {
    /**
     * @description Returns all comments for an issue.
     *  <p>
     *  Results can be ordered by the "created" field which means the date a comment was added.
     *  </p>
     */
    get: operations["getComments"];
    /** @description Adds a new comment to an issue. */
    post: operations["addComment"];
    parameters: {
      path: {
        /** @description a string containing the issue id or key the comment will be added to */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/comment/{id}": {
    /** @description Returns a single comment. */
    get: operations["getComment"];
    /** @description Updates an existing comment using its JSON representation. */
    put: operations["updateComment"];
    /** @description Deletes an existing comment . */
    delete: operations["deleteComment"];
    parameters: {
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
        /** @description the ID of the comment to request */
        id: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/comment/{id}/pin": {
    put: operations["setPinComment"];
    parameters: {
      path: {
        issueIdOrKey: string;
        id: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/editmeta": {
    /**
     * @description Returns the meta data for editing an issue.
     *  <p/>
     *  The fields in the editmeta correspond to the fields in the edit screen for the issue.
     *  Fields not in the screen will not be in the editmeta.
     */
    get: operations["getEditIssueMeta"];
    parameters: {
      path: {
        /** @description the issue whose edit meta data you want to view */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/notify": {
    /** @description Sends a notification (email) to the list or recipients defined in the request. */
    post: operations["notify"];
    parameters: {
      path: {
        /** @description a string containing the issue id or key the comment will be added to */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/pinned-comments": {
    /** @description Returns all pinned to the issue comments. */
    get: operations["getPinnedComments"];
    parameters: {
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/properties": {
    /** @description Returns the keys of all properties for the issue identified by the key or by the id. */
    get: operations["getPropertiesKeys"];
    parameters: {
      path: {
        /** @description the issue from which keys will be returned. */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the issue identified by the key or by the id. The user who retrieves
     *  the property is required to have permissions to read the issue.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified issue's property.
     *  <p>
     *  You can use this resource to store a custom data against the issue identified by the key or by the id. The user
     *  who stores the data is required to have permissions to edit the issue.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the issue identified by the key or by the id. Ths user removing the property is required
     *  to have permissions to edit the issue.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the issue from which keys will be returned. */
        issueIdOrKey: string;
        /** @description the key of the property to return. */
        propertyKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/remotelink": {
    /** @description A REST sub-resource representing the remote issue links on the issue. */
    get: operations["getRemoteIssueLinks"];
    /**
     * @description Creates or updates a remote issue link from a JSON representation. If a globalId is provided and a remote issue link
     *  exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
     */
    post: operations["createOrUpdateRemoteIssueLink"];
    /** @description Delete the remote issue link with the given global id on the issue. */
    delete: operations["deleteRemoteIssueLinkByGlobalId"];
    parameters: {
      path: {
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/remotelink/{linkId}": {
    /** @description Get the remote issue link with the given id on the issue. */
    get: operations["getRemoteIssueLinkById"];
    /** @description Updates a remote issue link from a JSON representation. Any fields not provided are set to null. */
    put: operations["updateRemoteIssueLink"];
    /** @description Delete the remote issue link with the given id on the issue. */
    delete: operations["deleteRemoteIssueLinkById"];
    parameters: {
      path: {
        /** @description the id of the remote issue link */
        linkId: string;
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/restore": {
    /** @description Restores an archived issue. */
    put: operations["restoreIssue"];
    parameters: {
      path: {
        /** @description Issue id or issue key */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/subtask": {
    /** @description Returns an issue's subtask list */
    get: operations["getSubTasks"];
    parameters: {
      path: {
        /** @description The parent issue's key or id */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/subtask/move": {
    get: operations["canMoveSubTask"];
    /**
     * @description Reorders an issue's subtasks by moving the subtask at index "from"
     *  to index "to".
     */
    post: operations["moveSubTasks"];
    parameters: {
      path: {
        /** @description The parent issue's key or id */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/transitions": {
    /**
     * @description Get a list of the transitions possible for this issue by the current user, along with fields that are required and their types.
     *  <p/>
     *  Fields will only be returned if <code>expand=transitions.fields</code>.
     *  <p/>
     *  The fields in the metadata correspond to the fields in the transition screen for that transition.
     *  Fields not in the screen will not be in the metadata.
     */
    get: operations["getTransitions"];
    /**
     * @description Perform a transition on an issue.
     *  When performing the transition you can update or set other issue fields.
     *  <p/>
     *  The fields that can be set on transtion, in either the fields parameter or the update parameter can be determined
     *  using the <b>/rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields</b> resource.
     *  If a field is not configured to appear on the transition screen, then it will not be in the transition metadata, and a field
     *  validation error will occur if it is submitted.
     *  <p>
     *  The <code>updateHistory</code> param adds the issues retrieved by this method to the current user's issue history,
     *  if set to true (by default, the issue history does not include issues retrieved via the REST API).
     *  You can view the issue history in the Jira application, via the Issues dropdown or by using the
     *  <code>lastViewed</code> JQL field in an issue search.
     */
    post: operations["doTransition"];
    parameters: {
      path: {
        /** @description the issue you want to transition */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/votes": {
    /** @description A REST sub-resource representing the voters on the issue. */
    get: operations["getVotes"];
    /** @description Cast your vote in favour of an issue. */
    post: operations["addVote"];
    /** @description Remove your vote from an issue. (i.e. "unvote") */
    delete: operations["removeVote"];
    parameters: {
      path: {
        /** @description the issue to view voting information for */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/watchers": {
    /** @description Returns the list of watchers for the issue with the given key. */
    get: operations["getIssueWatchers"];
    /** @description Adds a user to an issue's watcher list. */
    post: operations["addWatcher"];
    /** @description Removes a user from an issue's watcher list. */
    delete: operations["removeWatcher"];
    parameters: {
      path: {
        /** @description a String containing an issue key. */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/worklog": {
    /**
     * @description Returns all work logs for an issue. <br/>
     *  <strong>Note:</strong> Work logs won't be returned if the Log work field is hidden for the project.
     */
    get: operations["getIssueWorklog"];
    /** @description Adds a new worklog entry to an issue. */
    post: operations["addWorklog"];
    parameters: {
      path: {
        /** @description a string containing the issue id or key the worklog will be added to */
        issueIdOrKey: string;
      };
    };
  };
  "/api/2/issue/{issueIdOrKey}/worklog/{id}": {
    /**
     * @description Returns a specific worklog. <br/>
     *  <strong>Note:</strong> The work log won't be returned if the Log work field is hidden for the project.
     */
    get: operations["getWorklog"];
    /**
     * @description Updates an existing worklog entry.
     *  <p>Note that:</p>
     *  <ul>
     *      <li>Fields possible for editing are: comment, visibility, started, timeSpent and timeSpentSeconds.</li>
     *      <li>Either timeSpent or timeSpentSeconds can be set.</li>
     *      <li>Fields which are not set will not be updated.</li>
     *      <li>For a request to be valid, it has to have at least one field change.</li>
     *  </ul>
     */
    put: operations["updateWorklog"];
    /** @description Deletes an existing worklog entry. */
    delete: operations["deleteWorklog"];
    parameters: {
      path: {
        /** @description a string containing the issue id or key the worklog belongs to */
        issueIdOrKey: string;
        /** @description id of the worklog to be deleted */
        id: string;
      };
    };
  };
  "/api/2/issueLink": {
    /**
     * @description Creates an issue link between two issues.
     *  The user requires the link issue permission for the issue which will be linked to another issue.
     *  The specified link type in the request is used to create the link and will create a link from the first issue
     *  to the second issue using the outward description. It also create a link from the second issue to the first issue using the
     *  inward description of the issue link type.
     *  It will add the supplied comment to the first issue. The comment can have a restriction who can view it.
     *  If group is specified, only users of this group can view this comment, if roleLevel is specified only users who have the specified role can view this comment.
     *  The user who creates the issue link needs to belong to the specified group or have the specified role.
     */
    post: operations["linkIssues"];
  };
  "/api/2/issueLink/{linkId}": {
    /** @description Returns an issue link with the specified id. */
    get: operations["getIssueLink"];
    /**
     * @description Deletes an issue link with the specified id.
     *  To be able to delete an issue link you must be able to view both issues and must have the link issue permission
     *  for at least one of the issues.
     */
    delete: operations["deleteIssueLink"];
    parameters: {
      path: {
        /** @description the issue link id. */
        linkId: string;
      };
    };
  };
  "/api/2/issueLinkType": {
    /**
     * @description Returns a list of available issue link types, if issue linking is enabled.
     *  Each issue link type has an id, a name and a label for the outward and inward link relationship.
     */
    get: operations["getIssueLinkTypes"];
    /** @description Create a new issue link type. */
    post: operations["createIssueLinkType"];
  };
  "/api/2/issueLinkType/{issueLinkTypeId}": {
    /** @description Returns for a given issue link type id all information about this issue link type. */
    get: operations["getIssueLinkType"];
    /** @description Update the specified issue link type. */
    put: operations["updateIssueLinkType"];
    /** @description Delete the specified issue link type. */
    delete: operations["deleteIssueLinkType"];
    parameters: {
      path: {
        issueLinkTypeId: string;
      };
    };
  };
  "/api/2/issuesecurityschemes": {
    /** @description Returns all issue security schemes that are defined. */
    get: operations["getIssueSecuritySchemes"];
  };
  "/api/2/issuesecurityschemes/{id}": {
    /** @description Returns the issue security scheme along with that are defined. */
    get: operations["getIssueSecurityScheme"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/api/2/issuetype": {
    /** @description Returns a list of all issue types visible to the user */
    get: operations["getIssueAllTypes"];
    /**
     * @description Creates an issue type from a JSON representation and adds the issue newly created issue type to the default issue
     *  type scheme.
     */
    post: operations["createIssueType"];
  };
  "/api/2/issuetype/page": {
    /** @description Returns paginated list of filtered issue types */
    get: operations["getPaginatedIssueTypes"];
  };
  "/api/2/issuetype/{id}": {
    /** @description Returns a full representation of the issue type that has the given id. */
    get: operations["getIssueType"];
    /** @description Updates the specified issue type from a JSON representation. */
    put: operations["updateIssueType"];
    /**
     * @description Deletes the specified issue type. If the issue type has any associated issues, these issues will be migrated to
     *  the alternative issue type specified in the parameter. You can determine the alternative issue types by calling
     *  the <b>/rest/api/2/issuetype/{id}/alternatives</b> resource.
     */
    delete: operations["deleteIssueType"];
    parameters: {
      path: {
        /** @description a String containing an issue type id */
        id: string;
      };
    };
  };
  "/api/2/issuetype/{id}/alternatives": {
    /**
     * @description Returns a list of all alternative issue types for the given issue type id. The list will contain these issues types, to which
     *  issues assigned to the given issue type can be migrated. The suitable alternatives are issue types which are assigned
     *  to the same workflow, the same field configuration and the same screen scheme.
     */
    get: operations["getAlternativeIssueTypes"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/2/issuetype/{id}/avatar": {
    /** @description Converts temporary avatar into a real avatar */
    post: operations["createAvatarFromTemporary"];
    parameters: {
      path: {
        /** @description the id of the issue type, which avatar is updated. */
        id: string;
      };
    };
  };
  "/api/2/issuetype/{id}/avatar/temporary": {
    /**
     * @description Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because
     *  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from
     *  which the client parses the JSON from.
     *  <p>
     *  Creating a temporary avatar is part of a 3-step process in uploading a new
     *  avatar for an issue type: upload, crop, confirm. This endpoint allows you to use a multipart upload
     *  instead of sending the image directly as the request body.
     *  </p>
     *  <p>
     *  You *must* use "avatar" as the name of the upload parameter:</p>
     *  <p>
     *  <pre>
     *  curl -c cookiejar.txt -X POST -u admin:admin -H "X-Atlassian-Token: no-check" \
     *    -F "avatar=@mynewavatar.png;type=image/png" \
     *    'http://localhost:8090/jira/rest/api/2/issuetype/1/avatar/temporary'
     *  </pre>
     */
    post: operations["storeTemporaryAvatarUsingMultiPart"];
    parameters: {
      path: {
        /** @description the id of the issue type, which avatar is updated. */
        id: string;
      };
    };
  };
  "/api/2/issuetype/{issueTypeId}/properties": {
    /** @description Returns the keys of all properties for the issue type identified by the id. */
    get: operations["getPropertyKeys"];
    parameters: {
      path: {
        /** @description the issue type from which the keys will be returned */
        issueTypeId: string;
      };
    };
  };
  "/api/2/issuetype/{issueTypeId}/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the issue type identified by the id. The user who retrieves
     *  the property is required to have permissions to view the issue type.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified issue type's property.
     *  <p>
     *  You can use this resource to store a custom data against an issue type identified by the id. The user
     *  who stores the data is required to have permissions to edit an issue type.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the issue type identified by the id. Ths user removing the property is required
     *  to have permissions to edit the issue type.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the issue type from which the keys will be returned */
        issueTypeId: string;
        /** @description the key of the property to return */
        propertyKey: string;
      };
    };
  };
  "/api/2/issuetypescheme": {
    /**
     * @description Returns a list of all issue type schemes visible to the user (must be admin).
     *  <p>
     *      All issue types associated with the scheme will only be returned if an additional query parameter is provided:
     *      <code>expand=schemes.issueTypes</code>.
     *  </p>
     *  <p>
     *      Similarly, the default issue type associated with the scheme (if one exists) will only be returned if
     *      additional an query parameter is provided: <code>expand=schemes.defaultIssueType</code>.
     *  </p>
     *  <p>
     *      Note that both query parameters can be used together: <code>expand=schemes.issueTypes,schemes.defaultIssueType</code>.
     *  </p>
     */
    get: operations["getAllIssueTypeSchemes"];
    /** @description Creates an issue type scheme from a JSON representation. (Admin required) */
    post: operations["createIssueTypeScheme"];
  };
  "/api/2/issuetypescheme/{schemeId}": {
    /** @description Returns a full representation of the issue type scheme that has the given id (must be admin). */
    get: operations["getIssueTypeScheme"];
    /** @description Updates the specified issue type scheme from a JSON representation. (Admin required) */
    put: operations["updateIssueTypeScheme"];
    /**
     * @description Deletes the specified issue type scheme. Any projects associated with this IssueTypeScheme will be automatically
     *  associated with the global default IssueTypeScheme. (Admin required)
     */
    delete: operations["deleteIssueTypeScheme"];
    parameters: {
      path: {
        /** @description the id of the issue type scheme to remove. */
        schemeId: string;
      };
    };
  };
  "/api/2/issuetypescheme/{schemeId}/associations": {
    /** @description For the specified issue type scheme, returns all of the associated projects. (Admin required) */
    get: operations["getAssociatedProjects"];
    /**
     * @description Associates the given projects with the specified issue type scheme. Any existing project-associations the issue
     *  type scheme has will be overwritten.  (Admin required)
     */
    put: operations["setProjectAssociationsForScheme"];
    /** @description Adds additional projects to those already associated with the specified issue type scheme. (Admin required) */
    post: operations["addProjectAssociationsToScheme"];
    /**
     * @description Removes all project associations for the specified issue type scheme. These projects revert to an association with
     *  the default/global issue type scheme.(Admin required)
     */
    delete: operations["removeAllProjectAssociations"];
    parameters: {
      path: {
        /** @description the id of the issue type scheme whose project associations we're removing */
        schemeId: string;
      };
    };
  };
  "/api/2/issuetypescheme/{schemeId}/associations/{projIdOrKey}": {
    /**
     * @description For the specified issue type scheme, removes the given project association . This project reverts to an association
     *  with the default/global issue type scheme.(Admin required)
     */
    delete: operations["removeProjectAssociation"];
    parameters: {
      path: {
        /** @description the id or key of the project that is to be un-associated with the issue type scheme */
        projIdOrKey: string;
        /** @description the id of the issue type scheme whose project association we're removing */
        schemeId: string;
      };
    };
  };
  "/api/2/jql/autocompletedata": {
    /** @description Returns the auto complete data required for JQL searches. */
    get: operations["getAutoComplete"];
  };
  "/api/2/jql/autocompletedata/suggestions": {
    /** @description Returns auto complete suggestions for JQL search. */
    get: operations["getFieldAutoCompleteForQueryString"];
  };
  "/api/2/licenseValidator": {
    post: operations["validate"];
  };
  "/api/2/monitoring/app": {
    get: operations["isAppMonitoringEnabled"];
    post: operations["setAppMonitoringEnabled"];
  };
  "/api/2/monitoring/ipd": {
    get: operations["isIpdMonitoringEnabled"];
    post: operations["setAppMonitoringEnabled"];
  };
  "/api/2/monitoring/jmx/areMetricsExposed": {
    get: operations["areMetricsExposed"];
  };
  "/api/2/monitoring/jmx/getAvailableMetrics": {
    get: operations["getAvailableMetrics"];
  };
  "/api/2/monitoring/jmx/startExposing": {
    post: operations["start"];
  };
  "/api/2/monitoring/jmx/stopExposing": {
    post: operations["stop"];
  };
  "/api/2/mypermissions": {
    /**
     * @description Returns all permissions in the system and whether the currently logged in user has them. You can optionally provide a specific context to get permissions for
     *  (projectKey OR projectId OR issueKey OR issueId)
     *  <ul>
     *  <li> When no context supplied the project related permissions will return true if the user has that permission in ANY project </li>
     *  <li> If a project context is provided, project related permissions will return true if the user has the permissions in the specified project.
     *  For permissions that are determined using issue data (e.g Current Assignee), true will be returned if the user meets the permission criteria in ANY issue in that project </li>
     *  <li> If an issue context is provided, it will return whether or not the user has each permission in that specific issue</li>
     *  </ul>
     *  <p>
     *  NB: The above means that for issue-level permissions (EDIT_ISSUE for example), hasPermission may be true when no context is provided, or when a project context is provided,
     *  <b>but</b> may be false for any given (or all) issues. This would occur (for example) if Reporters were given the EDIT_ISSUE permission. This is because
     *  any user could be a reporter, except in the context of a concrete issue, where the reporter is known.
     *  </p>
     *  <p>
     *  Global permissions will still be returned for all scopes.
     *  </p>
     *  <p>
     *  Prior to version 6.4 this service returned project permissions with keys corresponding to com.atlassian.jira.security.Permissions.Permission constants.
     *  Since 6.4 those keys are considered deprecated and this service returns system project permission keys corresponding to constants defined in com.atlassian.jira.permission.ProjectPermissions.
     *  Permissions with legacy keys are still also returned for backwards compatibility, they are marked with an attribute deprecatedKey=true.
     *  The attribute is missing for project permissions with the current keys.
     *  </p>
     */
    get: operations["getPermissions"];
  };
  "/api/2/mypreferences": {
    /**
     * @description Returns preference of the currently logged in user. Preference key must be provided as input parameter (key). The
     *  value is returned exactly as it is. If key parameter is not provided or wrong - status code 404. If value is
     *  found  - status code 200.
     */
    get: operations["getPreference"];
    /**
     * @description Sets preference of the currently logged in user. Preference key must be provided as input parameters (key). Value
     *  must be provided as post body. If key or value parameter is not provided - status code 404. If preference is set
     *  - status code 204.
     */
    put: operations["setPreference"];
    /**
     * @description Removes preference of the currently logged in user. Preference key must be provided as input parameters (key). If
     *  key parameter is not provided or wrong - status code 404. If preference is unset - status code 204.
     */
    delete: operations["removePreference"];
  };
  "/api/2/myself": {
    /** @description Returns currently logged user. This resource cannot be accessed anonymously. */
    get: operations["getUser"];
    /**
     * @description Modify currently logged user. The "value" fields present will override the existing value.
     *  Fields skipped in request will not be changed. Only email and display name can be change that way.
     *  Requires user password.
     */
    put: operations["updateUser"];
  };
  "/api/2/myself/password": {
    /** @description Modify caller password. */
    put: operations["changeMyPassword"];
  };
  "/api/2/notificationscheme": {
    /**
     * @description Returns a <a href="#pagination">paginated</a> list of notification schemes. In order to access notification scheme, the calling user is
     *  required to have permissions to administer at least one project associated with the requested notification scheme. Each scheme contains
     *  a list of events and recipient configured to receive notifications for these events. Consumer should allow events without recipients to appear in response.
     *  The list is ordered by the scheme's name.
     *  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
     */
    get: operations["getNotificationSchemes"];
  };
  "/api/2/notificationscheme/{id}": {
    /**
     * @description Returns a full representation of the notification scheme for the given id. This resource will return a
     *  notification scheme containing a list of events and recipient configured to receive notifications for these events. Consumer
     *  should allow events without recipients to appear in response. User accessing
     *  the data is required to have permissions to administer at least one project associated with the requested notification scheme.
     *  <p>
     *  Notification recipients can be:
     *  <ul>
     *  <li>current assignee - the value of the notificationType is CurrentAssignee</li>
     *  <li>issue reporter - the value of the notificationType is Reporter</li>
     *  <li>current user - the value of the notificationType is CurrentUser</li>
     *  <li>project lead - the value of the notificationType is ProjectLead</li>
     *  <li>component lead - the value of the notificationType is ComponentLead</li>
     *  <li>all watchers - the value of the notification type is AllWatchers</li>
     *  <li>configured user - the value of the notification type is User. Parameter will contain key of the user. Information about the user will be provided
     *  if <b>user</b> expand parameter is used. </li>
     *  <li>configured group - the value of the notification type is Group. Parameter will contain name of the group. Information about the group will be provided
     *  if <b>group</b> expand parameter is used. </li>
     *  <li>configured email address - the value of the notification type is EmailAddress, additionally information about the email will be provided.</li>
     *  <li>users or users in groups in the configured custom fields - the value of the notification type is UserCustomField or GroupCustomField. Parameter
     *  will contain id of the custom field. Information about the field will be provided if <b>field</b> expand parameter is used. </li>
     *  <li>configured project role - the value of the notification type is ProjectRole. Parameter will contain project role id. Information about the project role
     *  will be provided if <b>projectRole</b> expand parameter is used. </li>
     *  </ul>
     *  Please see the example for reference.
     *  </p>
     *  The events can be Jira system events or events configured by administrator. In case of the system events, data about theirs
     *  ids, names and descriptions is provided. In case of custom events, the template event is included as well.
     */
    get: operations["getNotificationScheme"];
    parameters: {
      path: {
        /** @description an id of the notification scheme to retrieve */
        id: number;
      };
    };
  };
  "/api/2/password/policy": {
    /**
     * @description Returns the list of requirements for the current password policy. For example, "The password must have at least 10 characters.",
     *  "The password must not be similar to the user's name or email address.", etc.
     */
    get: operations["getPasswordPolicy"];
  };
  "/api/2/password/policy/createUser": {
    /**
     * @description Returns a list of statements explaining why the password policy would disallow a proposed password for a new user.
     *  <p>
     *  You can use this method to test the password policy validation. This could be done prior to an action
     *  where a new user and related password are created, using methods like the ones in
     *  <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/user/UserService.html">UserService</a>.
     *  For example, you could use this to validate a password in a create user form in the user interface, as the user enters it.<br/>
     *  The username and new password must be not empty to perform the validation.<br/>
     *  Note, this method will help you validate against the policy only. It won't check any other validations that might be performed
     *  when creating a new user, e.g. checking whether a user with the same name already exists.
     *  </p>
     */
    post: operations["policyCheckCreateUser"];
  };
  "/api/2/password/policy/updateUser": {
    /**
     * @description Returns a list of statements explaining why the password policy would disallow a proposed new password for a user with an existing password.
     *  <p>
     *  You can use this method to test the password policy validation. This could be done prior to an action where the password
     *  is actually updated, using methods like <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ChangePassword.html">ChangePassword</a>
     *  or <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ResetPassword.html">ResetPassword</a>.
     *  For example, you could use this to validate a password in a change password form in the user interface, as the user enters it.<br/>
     *  The user must exist and the username and new password must be not empty, to perform the validation.<br/>
     *  Note, this method will help you validate against the policy only. It won't check any other validations that might be performed
     *  when submitting a password change/reset request, e.g. verifying whether the old password is valid.
     *  </p>
     */
    post: operations["policyCheckUpdateUser"];
  };
  "/api/2/permissions": {
    /** @description Returns all permissions that are present in the Jira instance - Global, Project and the global ones added by plugins */
    get: operations["getAllPermissions"];
  };
  "/api/2/permissionscheme": {
    /**
     * @description Returns a list of all permission schemes.
     *  <p>
     *  By default only shortened beans are returned. If you want to include permissions of all the schemes,
     *  then specify the <b>permissions</b> expand parameter. Permissions will be included also if you specify
     *  any other expand parameter.
     *  </p>
     */
    get: operations["getPermissionSchemes"];
    /**
     * @description Create a new permission scheme.
     *  This method can create schemes with a defined permission set, or without.
     */
    post: operations["createPermissionScheme"];
  };
  "/api/2/permissionscheme/{permissionSchemeId}/attribute/{attributeKey}": {
    get: operations["getSchemeAttribute"];
    parameters: {
      path: {
        /** @description permission scheme id */
        permissionSchemeId: number;
        /** @description permission scheme attribute key */
        attributeKey: string;
      };
    };
  };
  "/api/2/permissionscheme/{permissionSchemeId}/attribute/{key}": {
    /**
     * @description Updates or inserts the attribute for a permission scheme specified by permission scheme id.
     *  The attribute consists of the key and the value. The value will be converted to Boolean using Boolean#valueOf.
     */
    put: operations["setSchemeAttribute"];
    parameters: {
      path: {
        /** @description permission scheme id */
        permissionSchemeId: number;
        /** @description permission scheme attribute key */
        key: string;
      };
    };
  };
  "/api/2/permissionscheme/{schemeId}": {
    /** @description Returns a permission scheme identified by the given id. */
    get: operations["getPermissionScheme"];
    /**
     * @description Updates a permission scheme.
     *  <p>
     *  If the permissions list is present then it will be set in the permission scheme, which basically means it will overwrite any permission grants that
     *  existed in the permission scheme. Sending an empty list will remove all permission grants from the permission scheme.
     *  </p>
     *  <p>
     *  To update just the name and description, do not send permissions list at all.
     *  </p>
     *  <p>
     *  To add or remove a single permission grant instead of updating the whole list at once use the <b>{schemeId}/permission/</b> resource.
     *  </p>
     */
    put: operations["updatePermissionScheme"];
    /** @description Deletes a permission scheme identified by the given id. */
    delete: operations["deletePermissionScheme"];
    parameters: {
      path: {
        schemeId: number;
      };
    };
  };
  "/api/2/permissionscheme/{schemeId}/permission": {
    /** @description Returns all permission grants of the given permission scheme. */
    get: operations["getPermissionSchemeGrants"];
    /** @description Creates a permission grant in a permission scheme. */
    post: operations["createPermissionGrant"];
    parameters: {
      path: {
        schemeId: number;
      };
    };
  };
  "/api/2/permissionscheme/{schemeId}/permission/{permissionId}": {
    /** @description Returns a permission grant identified by the given id. */
    get: operations["getPermissionSchemeGrant"];
    /** @description Deletes a permission grant from a permission scheme. */
    delete: operations["deletePermissionSchemeEntity"];
    parameters: {
      path: {
        permissionId: number;
        schemeId: number;
      };
    };
  };
  "/api/2/priority": {
    /** @description Returns a list of all issue priorities. */
    get: operations["getPriorities"];
  };
  "/api/2/priority/page": {
    /** @description Returns a list of all issue priorities. */
    get: operations["getPriorities"];
  };
  "/api/2/priority/{id}": {
    /** @description Returns an issue priority. */
    get: operations["getPriority"];
    parameters: {
      path: {
        /** @description a String containing the priority id */
        id: string;
      };
    };
  };
  "/api/2/priorityschemes": {
    /**
     * @description Returns all priority schemes.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=schemes.projectKeys</code>.
     */
    get: operations["getPrioritySchemes"];
    /** @description Creates new priority scheme. */
    post: operations["createPriorityScheme"];
  };
  "/api/2/priorityschemes/{schemeId}": {
    /**
     * @description Gets a full representation of a priority scheme in JSON format.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
     */
    get: operations["getPriorityScheme"];
    /**
     * @description Updates a priority scheme.
     *  Update will be rejected if issue migration would be needed as a result of scheme update.
     *  Priority scheme update with migration is possible from the UI.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
     */
    put: operations["updatePriorityScheme"];
    /**
     * @description Deletes a priority scheme. All projects using deleted scheme will use default priority scheme afterwards.
     *
     *  Default priority scheme can't be deleted.
     */
    delete: operations["deletePriorityScheme"];
    parameters: {
      path: {
        /** @description id of priority scheme to get */
        schemeId: number;
      };
    };
  };
  "/api/2/project": {
    /**
     * @description Returns all projects which are visible for the currently logged in user. If no user is logged in, it returns the
     *  list of projects that are visible when using anonymous access.
     */
    get: operations["getAllProjects"];
    /** @description Creates a new project. */
    post: operations["createProject"];
  };
  "/api/2/project/type": {
    /**
     * @description Returns all the project types defined on the Jira instance, not taking into account whether
     *  the license to use those project types is valid or not.
     */
    get: operations["getAllProjectTypes"];
  };
  "/api/2/project/type/{projectTypeKey}": {
    /** @description Returns the project type with the given key. */
    get: operations["getProjectTypeByKey"];
    parameters: {
      path: {
        projectTypeKey: string;
      };
    };
  };
  "/api/2/project/type/{projectTypeKey}/accessible": {
    /**
     * @description Returns the project type with the given key, if it is accessible to the logged in user.
     *  This takes into account whether the user is licensed on the Application that defines the project type.
     */
    get: operations["getAccessibleProjectTypeByKey"];
    parameters: {
      path: {
        projectTypeKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}": {
    /**
     * @description Contains a full representation of a project in JSON format.
     *  <p>
     *  All project keys associated with the project will only be returned if <code>expand=projectKeys</code>.
     *  <p>
     */
    get: operations["getProject"];
    /**
     * @description Updates a project.
     *  <p>
     *  Only non null values sent in JSON will be updated in the project.</p>
     *  <p>
     *  Values available for the assigneeType field are: "PROJECT_LEAD" and "UNASSIGNED".</p>
     */
    put: operations["updateProject"];
    /** @description Deletes a project. */
    delete: operations["deleteProject"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/archive": {
    /** @description Archives a project. */
    put: operations["archiveProject"];
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/avatar": {
    /**
     * @description Updates an avatar for a project. This is step 3/3 of changing an avatar for a project:
     *
     *  <ul>
     *  <li>Upload (store temporary avatar)</li>
     *  <li>Crop (create avatar from temporary)</li>
     *  <li><b>Update (update project avatar)</b></li>
     *  </ul>
     */
    put: operations["updateProjectAvatar"];
    /**
     * @description Converts the temporary avatar into the final one. This is step 2/3 of changing an avatar for a project:
     *
     *  <ul>
     *  <li>Upload (store temporary avatar)</li>
     *  <li><b>Crop (create avatar from temporary)</b></li>
     *  <li>Update (update project avatar)</li>
     *  </ul>
     */
    post: operations["createAvatarFromTemporary"];
    parameters: {
      path: {
        /** @description project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/avatar/temporary": {
    /**
     * @description Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because
     *  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from
     *  which the client parses the JSON.
     */
    post: operations["storeTemporaryAvatarUsingMultiPart"];
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/avatar/{id}": {
    /** @description Deletes avatar */
    delete: operations["deleteAvatar"];
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
        /** @description database id for avatar */
        id: number;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/avatars": {
    /**
     * @description Returns all avatars which are visible for the currently logged in user.  The avatars are grouped into
     *  system and custom.
     */
    get: operations["getAllAvatars"];
    parameters: {
      path: {
        /** @description project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/components": {
    /** @description Contains a full representation of a the specified project's components. */
    get: operations["getProjectComponents"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/properties": {
    /** @description Returns the keys of all properties for the project identified by the key or by the id. */
    get: operations["getPropertiesKeys"];
    parameters: {
      path: {
        /** @description the project from which keys will be returned. */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the project identified by the key or by the id. The user who retrieves
     *  the property is required to have permissions to read the project.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified project's property.
     *  <p>
     *  You can use this resource to store a custom data against the project identified by the key or by the id. The user
     *  who stores the data is required to have permissions to administer the project.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the project identified by the key or by the id. Ths user removing the property is required
     *  to have permissions to administer the project.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the project from which keys will be returned. */
        projectIdOrKey: string;
        /** @description the key of the property to return. */
        propertyKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/restore": {
    /**
     * @description Restore an archived project.
     *  In case of success restored project should be re-indexed.
     */
    put: operations["restoreProject"];
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/role": {
    /** @description Returns all roles in the given project Id or key, with links to full details on each role. */
    get: operations["getProjectRoles"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/role/{id}": {
    /** @description Returns the details for a given project role in a project. */
    get: operations["getProjectRole"];
    /**
     * @description Updates a project role to include the specified actors (users or groups). Can be also used to clear roles to not include any users or groups.
     *  <p>
     *  For user actors, their usernames should be used.
     */
    put: operations["setActors"];
    /**
     * @description Adds an actor (user or group) to a project role.
     *  <p>
     *  For user actors, their usernames should be used.
     */
    post: operations["addActorUsers"];
    /**
     * @description Deletes actors (users or groups) from a project role.
     *  <p>
     *  <ul>
     *  <li>Delete a user from the role: <code>/rest/api/2/project/{projectIdOrKey}/role/{roleId}?user={username}</code></li>
     *  <li>Delete a group from the role: <code>/rest/api/2/project/{projectIdOrKey}/role/{roleId}?group={groupname}</code></li>
     *  </ul>
     */
    delete: operations["deleteActor"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
        /** @description the project role id */
        id: number;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/statuses": {
    /** @description Get all issue types with valid status values for a project */
    get: operations["getAllStatuses"];
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/type/{newProjectTypeKey}": {
    /** @description Updates the type of a project. */
    put: operations["updateProjectType"];
    parameters: {
      path: {
        /** @description identity of the project to update */
        projectIdOrKey: string;
        /** @description The key of the new project type */
        newProjectTypeKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/version": {
    /**
     * @description Returns all versions for the specified project. Results are <a href="#pagination">paginated</a>.
     *  <p>
     *  Results can be ordered by the following fields:
     *  <ul>
     *  <li>sequence</li>
     *  <li>name</li>
     *  <li>startDate</li>
     *  <li>releaseDate</li>
     *  </ul>
     *  </p>
     */
    get: operations["getProjectVersionsPaginated"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectIdOrKey}/versions": {
    /** @description Contains a full representation of a the specified project's versions. */
    get: operations["getProjectVersions"];
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/issuesecuritylevelscheme": {
    /** @description Returns the issue security scheme for project. */
    get: operations["getIssueSecurityScheme"];
    parameters: {
      path: {
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/notificationscheme": {
    /**
     * @description Gets a notification scheme associated with the project.
     *  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
     */
    get: operations["getNotificationScheme"];
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/permissionscheme": {
    /** @description Gets a permission scheme assigned with a project. */
    get: operations["getAssignedPermissionScheme"];
    /** @description Assigns a permission scheme with a project. */
    put: operations["assignPermissionScheme"];
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/priorityscheme": {
    /**
     * @description Gets a full representation of a priority scheme in JSON format used by specified project.
     *  User must be global administrator or project administrator.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
     */
    get: operations["getAssignedPriorityScheme"];
    /**
     * @description Assigns project with priority scheme.
     *  Priority scheme assign with migration is possible from the UI.
     *
     *  Operation will fail if migration is needed as a result of operation eg. there are issues with priorities invalid in the destination scheme.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
     */
    put: operations["assignPriorityScheme"];
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/priorityscheme/{schemeId}": {
    /**
     * @description Unassigns project from priority scheme.
     *
     *  Operation will fail for defualt priority scheme, project is not found or project is not associated with provided priority scheme.
     *
     *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
     */
    delete: operations["unassignPriorityScheme"];
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
        /** @description object that contains an id of the scheme */
        schemeId: number;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/securitylevel": {
    /**
     * @description Returns all security levels for the project that the current logged in user has access to.
     *  If the user does not have the Set Issue Security permission, the list will be empty.
     */
    get: operations["getSecurityLevelsForProject"];
    parameters: {
      path: {
        /** @description - key or id of project to list the security levels for */
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/project/{projectKeyOrId}/workflowscheme": {
    /** @description Returns the workflow scheme that is associated with requested project. */
    get: operations["getWorkflowSchemeForProject"];
    parameters: {
      path: {
        /** @description the key or id of the project. */
        projectKeyOrId: string;
      };
    };
  };
  "/api/2/projectCategory": {
    /** @description Returns all project categories */
    get: operations["getAllProjectCategories"];
    /** @description Create a project category via POST. */
    post: operations["createProjectCategory"];
  };
  "/api/2/projectCategory/{id}": {
    /** @description Contains a representation of a project category in JSON format. */
    get: operations["getProjectCategoryById"];
    /**
     * @description Modify a project category via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
     *  is not present, it is silently ignored.
     */
    put: operations["updateProjectCategory"];
    /** @description Delete a project category. */
    delete: operations["removeProjectCategory"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/api/2/projects/picker": {
    /**
     * @description Returns a list of projects visible to the user where project name and/or key is matching the given query.
     *  <p>
     *  Passing an empty (or whitespace only) query will match no projects. The project matches will
     *  contain a field with the query highlighted.
     *  <p>
     *  The number of projects returned can be controlled by passing a value for "maxResults", but a hard limit of no
     *  more than 100 projects is enforced. The projects are wrapped in a single response object that contains
     *  a header for use in the picker, specifically <i>Showing X of Y matching projects</i> and the total number
     *  of matches for the query.
     */
    get: operations["searchForProjects"];
  };
  "/api/2/projectvalidate/key": {
    /** @description Validates a project key. */
    get: operations["getProject"];
  };
  "/api/2/reindex": {
    /**
     * @description Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.
     *  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404
     *  indicating that no reindex has taken place.
     */
    get: operations["getReindexInfo"];
    /** @description Kicks off a reindex.  Need Admin permissions to perform this reindex. */
    post: operations["reindex"];
  };
  "/api/2/reindex/issue": {
    /**
     * @description Reindexes one or more individual issues.  Indexing is performed synchronously - the call returns when indexing of
     *  the issues has completed or a failure occurs.
     *  <p>
     *  Use either explicitly specified issue IDs or a JQL query to select issues to reindex.
     */
    post: operations["reindexIssues"];
  };
  "/api/2/reindex/progress": {
    /**
     * @description Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.
     *  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404
     *  indicating that no reindex has taken place.
     */
    get: operations["getReindexProgress"];
  };
  "/api/2/reindex/request": {
    /**
     * @description Executes any pending reindex requests.  Returns a JSON array containing the IDs of the reindex requests
     *  that are being processed.  Execution is asynchronous - progress of the returned tasks can be monitored through
     *  other REST calls.
     */
    post: operations["processRequests"];
  };
  "/api/2/reindex/request/bulk": {
    /**
     * @description Retrieves the progress of a multiple reindex requests.  Only reindex requests that actually exist will be returned
     *  in the results.
     */
    get: operations["getProgressBulk"];
  };
  "/api/2/reindex/request/{requestId}": {
    /** @description Retrieves the progress of a single reindex request. */
    get: operations["getProgress"];
    parameters: {
      path: {
        /** @description the reindex request ID. */
        requestId: number;
      };
    };
  };
  "/api/2/resolution": {
    /** @description Returns a list of all resolutions. */
    get: operations["getResolutions"];
  };
  "/api/2/resolution/page": {
    /** @description Returns paginated list of filtered resolutions */
    get: operations["getPaginatedResolutions"];
  };
  "/api/2/resolution/{id}": {
    /** @description Returns a resolution. */
    get: operations["getResolution"];
    parameters: {
      path: {
        /** @description a String containing the resolution id */
        id: string;
      };
    };
  };
  "/api/2/role": {
    /** @description Get all the ProjectRoles available in Jira. Currently this list is global. */
    get: operations["getProjectRoles"];
    /**
     * @description Creates a new ProjectRole to be available in Jira.
     *  The created role does not have any default actors assigned.
     */
    post: operations["createProjectRole"];
  };
  "/api/2/role/{id}": {
    /** @description Get a specific ProjectRole available in Jira. */
    get: operations["getProjectRolesById"];
    /** @description Fully updates a roles. Both name and description must be given. */
    put: operations["fullyUpdateProjectRole"];
    /** @description Partially updates a roles name or description. */
    post: operations["partialUpdateProjectRole"];
    /** @description Deletes a role. May return 403 in the future */
    delete: operations["deleteProjectRole"];
    parameters: {
      path: {
        id: number;
      };
    };
  };
  "/api/2/role/{id}/actors": {
    /** @description Gets default actors for the given role. */
    get: operations["getProjectRoleActorsForRole"];
    /** @description Adds default actors to the given role. The request data should contain a list of usernames or a list of groups to add. */
    post: operations["addProjectRoleActorsToRole"];
    /** @description Removes default actor from the given role. */
    delete: operations["deleteProjectRoleActorsFromRole"];
    parameters: {
      path: {
        /** @description the role id to remove the actors from */
        id: number;
      };
    };
  };
  "/api/2/screens": {
    /** @description Gets available field screens */
    get: operations["getAllScreens"];
  };
  "/api/2/screens/addToDefault/{fieldId}": {
    /** @description Adds field or custom field to the default tab */
    post: operations["addFieldToDefaultScreen"];
    parameters: {
      path: {
        /** @description id of field / custom field */
        fieldId: string;
      };
    };
  };
  "/api/2/screens/{screenId}/availableFields": {
    /** @description Gets available fields for screen. i.e ones that haven't already been added. */
    get: operations["getFieldsToAdd"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs": {
    /** @description Returns a list of all tabs for the given screen */
    get: operations["getAllTabs"];
    /** @description Creates tab for given screen */
    post: operations["addTab"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}": {
    /** @description Renames tab on given screen */
    put: operations["renameTab"];
    /** @description Deletes tab to give screen */
    delete: operations["deleteTab"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}/fields": {
    /** @description Gets all fields for a given tab */
    get: operations["getAllFields"];
    /** @description Adds field to the given tab. */
    post: operations["addField"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}": {
    /** @description Removes field from given tab */
    delete: operations["removeField"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        id: string;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/move": {
    /** @description Moves field on the given tab */
    post: operations["moveField"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        id: string;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/updateShowWhenEmptyIndicator/{newValue}": {
    /** @description Update 'showWhenEmptyIndicator' for given field on screen */
    put: operations["updateShowWhenEmptyIndicator"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        /** @description new value of 'showWhenEmptyIndicator' */
        newValue: boolean;
        /** @description id of field */
        id: string;
      };
    };
  };
  "/api/2/screens/{screenId}/tabs/{tabId}/move/{pos}": {
    /** @description Moves tab position */
    post: operations["moveTab"];
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        /** @description position of tab */
        pos: number;
      };
    };
  };
  "/api/2/search": {
    /**
     * @description Searches for issues using JQL.
     *  <p>
     *  <b>Sorting</b>
     *  the <code>jql</code> parameter is a full <a href="http://confluence.atlassian.com/display/JIRA/Advanced+Searching">JQL</a>
     *  expression, and includes an <code>ORDER BY</code> clause.
     *  </p>
     *  <p>
     *  The <code>fields</code> param (which can be specified multiple times) gives a comma-separated list of fields
     *  to include in the response. This can be used to retrieve a subset of fields.
     *  A particular field can be excluded by prefixing it with a minus.
     *  <p>
     *  By default, only navigable (<code>*navigable</code>) fields are returned in this search resource. Note: the default is different
     *  in the get-issue resource -- the default there all fields (<code>*all</code>).
     *  <ul>
     *  <li><code>*all</code> - include all fields</li>
     *  <li><code>*navigable</code> - include just navigable fields</li>
     *  <li><code>summary,comment</code> - include just the summary and comments</li>
     *  <li><code>-description</code> - include navigable fields except the description (the default is <code>*navigable</code> for search)</li>
     *  <li><code>*all,-comment</code> - include everything except comments</li>
     *  </ul>
     *  <p>
     *  </p>
     *  <p><b>GET vs POST:</b>
     *  If the JQL query is too large to be encoded as a query param you should instead
     *  POST to this resource.
     *  </p>
     *  <p>
     *  <b>Expanding Issues in the Search Result:</b>
     *  It is possible to expand the issues returned by directly specifying the expansion on the expand parameter passed
     *  in to this resources.
     *  </p>
     *  <p>
     *  For instance, to expand the &quot;changelog&quot; for all the issues on the search result, it is neccesary to
     *  specify &quot;changelog&quot; as one of the values to expand.
     *  </p>
     */
    get: operations["search"];
    /** @description Performs a search using JQL. */
    post: operations["searchUsingSearchRequest"];
  };
  "/api/2/securitylevel/{id}": {
    /** @description Returns a full representation of the security level that has the given id. */
    get: operations["getIssuesecuritylevel"];
    parameters: {
      path: {
        /** @description a String containing an issue security level id */
        id: string;
      };
    };
  };
  "/api/2/serverInfo": {
    /** @description Returns general information about the current Jira server. */
    get: operations["getServerInfo"];
  };
  "/api/2/settings/baseUrl": {
    /** @description Sets the base URL that is configured for this Jira instance. */
    put: operations["setBaseURL"];
  };
  "/api/2/settings/columns": {
    /** @description Returns the default system columns for issue navigator. Admin permission will be required. */
    get: operations["getIssueNavigatorDefaultColumns"];
    /** @description Sets the default system columns for issue navigator. Admin permission will be required. */
    put: operations["setIssueNavigatorDefaultColumns"];
  };
  "/api/2/status": {
    /** @description Returns a list of all statuses */
    get: operations["getStatuses"];
  };
  "/api/2/status/page": {
    /** @description Returns paginated list of filtered statuses */
    get: operations["getPaginatedStatuses"];
  };
  "/api/2/status/{idOrName}": {
    /** @description Returns a full representation of the Status having the given id or name. */
    get: operations["getStatus"];
    parameters: {
      path: {
        /** @description a numeric Status id or a status name */
        idOrName: string;
      };
    };
  };
  "/api/2/statuscategory": {
    /** @description Returns a list of all status categories */
    get: operations["getStatusCategories"];
  };
  "/api/2/statuscategory/{idOrKey}": {
    /** @description Returns a full representation of the StatusCategory having the given id or key */
    get: operations["getStatusCategory"];
    parameters: {
      path: {
        /** @description a numeric StatusCategory id or a status category key */
        idOrKey: string;
      };
    };
  };
  "/api/2/terminology/entries": {
    /** @description Returns the list of all defined names for the default words "epic" and "sprint". */
    get: operations["getAllTerminologyEntries"];
    /**
     * @description Change epic/sprint names from {"originalName"} to {"newName"}. The {"newName"} will be displayed in Jira instead of {"originalName"}.
     *  <p>
     *  {"originalName"} must be equal to "epic" or "sprint".
     *  There can be only one entry per unique {"originalName"}.
     *  <p>
     *  {"newName"} can only consist of alphanumeric characters and spaces e.g. {"newName": "iteration number 2"}.
     *  <p>
     *  {"newName"} must be between 1 to 100 characters.
     *  It can't use the already defined {"newName"} values or <a href=https://confluence.atlassian.com/jiracoreserver/search-syntax-for-text-fields-939937723.html>restricted JQL words</a> .
     *  <p>
     *  To reset {"newName"} to the default value, enter the {"originalName"} value as the value for {"newName"}. For example, if you want to return to {"originalName": "sprint"}, enter {"newName": "sprint"}.
     */
    post: operations["setTerminologyEntries"];
  };
  "/api/2/terminology/entries/{originalName}": {
    /** @description Returns epic or sprint name as specified in the {originalName} path param. */
    get: operations["getTerminologyEntry"];
    parameters: {
      path: {
        originalName: string;
      };
    };
  };
  "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}": {
    get: operations["getAvatars"];
    parameters: {
      path: {
        type: string;
        owningObjectId: string;
      };
    };
  };
  "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/avatar": {
    post: operations["createAvatarFromTemporary"];
    parameters: {
      path: {
        type: string;
        owningObjectId: string;
      };
    };
  };
  "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}": {
    /** @description Deletes avatar */
    delete: operations["deleteAvatar"];
    parameters: {
      path: {
        /** @description database id for avatar */
        id: number;
        /** @description Project id or project key */
        type: string;
        owningObjectId: string;
      };
    };
  };
  "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/temp": {
    post: operations["storeTemporaryAvatarUsingMultiPart"];
    parameters: {
      path: {
        type: string;
        owningObjectId: string;
      };
    };
  };
  "/api/2/upgrade": {
    /**
     * @description Returns the result of the last upgrade task.
     *
     *  Returns {@link javax.ws.rs.core.Response#seeOther(java.net.URI)} if still running.
     */
    get: operations["getUpgradeResult"];
    /** @description Runs any pending delayed upgrade tasks.  Need Admin permissions to do this. */
    post: operations["runUpgradesNow"];
  };
  "/api/2/user": {
    /** @description Returns a user. This resource cannot be accessed anonymously. */
    get: operations["getUser"];
    /**
     * @description Modify user. The "value" fields present will override the existing value.
     *  Fields skipped in request will not be changed.
     */
    put: operations["updateUser"];
    /**
     * @description Create user. By default created user will not be notified with email.
     *  If password field is not set then password will be randomly generated.
     */
    post: operations["createUser"];
    /**
     * @description Removes user and its references (like project roles associations, watches, history).
     *  <br>
     *  <br>
     *  <b>Note:</b> user references will not be removed if multiple User Directories are used and there is a user with
     *  the same name existing in another directory (shadowing user).
     */
    delete: operations["removeUser"];
  };
  "/api/2/user/a11y/personal-settings": {
    /**
     * @description Returns available accessibility personal settings along with `enabled` property
     *  that indicates the currently logged-in user preference.
     */
    get: operations["getA11yPersonalSettings"];
  };
  "/api/2/user/anonymization": {
    /** @description Validates user anonymization process. */
    get: operations["validateUserAnonymization"];
    /** @description Schedules a user anonymization process. Requires system admin permission. */
    post: operations["scheduleUserAnonymization"];
  };
  "/api/2/user/anonymization/progress": {
    /** @description Returns information about a user anonymization operation progress. */
    get: operations["getProgress"];
  };
  "/api/2/user/anonymization/rerun": {
    /** @description Validates user anonymization re-run process. */
    get: operations["validateUserAnonymizationRerun"];
    /** @description Schedules a user anonymization process. Requires system admin permission. */
    post: operations["scheduleUserAnonymizationRerun"];
  };
  "/api/2/user/anonymization/unlock": {
    /**
     * @description Removes stale user anonymization task, for scenarios when the node that was executing it is no longer alive.
     *  <p>
     *  <strong>Use it only after making sure that the parent node of the task is actually down, and not just having
     *  connectivity issues.</strong>
     */
    delete: operations["unlockAnonymization"];
  };
  "/api/2/user/application": {
    /** @description Add user to given application. Admin permission will be required to perform this operation. */
    post: operations["addUserToApplication"];
    /** @description Remove user from given application. Admin permission will be required to perform this operation. */
    delete: operations["removeUserFromApplication"];
  };
  "/api/2/user/assignable/multiProjectSearch": {
    /** @description Returns a list of users that match the search string and can be assigned issues for all the given projects. */
    get: operations["findBulkAssignableUsers"];
  };
  "/api/2/user/assignable/search": {
    /**
     * @description Returns a list of users that match the search string. This resource cannot be accessed anonymously.
     *  Please note that this resource should be called with an issue key when a list of assignable users is retrieved
     *  for editing.  For create only a project key should be supplied.  The list of assignable users may be incorrect
     *  if it's called with the project key for editing.
     */
    get: operations["findAssignableUsers"];
  };
  "/api/2/user/avatar": {
    put: operations["updateUserAvatar"];
    /** @description Converts temporary avatar into a real avatar */
    post: operations["createAvatarFromTemporary"];
  };
  "/api/2/user/avatar/temporary": {
    /**
     * @description Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because
     *  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from
     *  which the client parses the JSON from.
     *  <p>
     *  Creating a temporary avatar is part of a 3-step process in uploading a new
     *  avatar for a user: upload, crop, confirm. This endpoint allows you to use a multipart upload
     *  instead of sending the image directly as the request body.
     *  </p>
     *  <p>
     *  You *must* use "avatar" as the name of the upload parameter:</p>
     *  <p/>
     *  <pre>
     *  curl -c cookiejar.txt -X POST -u admin:admin -H "X-Atlassian-Token: no-check" \
     *    -F "avatar=@mynewavatar.png;type=image/png" \
     *    'http://localhost:8090/jira/rest/api/2/user/avatar/temporary?username=admin'
     *  </pre>
     */
    post: operations["storeTemporaryAvatarUsingMultiPart"];
  };
  "/api/2/user/avatar/{id}": {
    /** @description Deletes avatar */
    delete: operations["deleteAvatar"];
    parameters: {
      path: {
        /** @description database id for avatar */
        id: number;
      };
    };
  };
  "/api/2/user/avatars": {
    /** @description Returns all avatars which are visible for the currently logged in user. */
    get: operations["getAllAvatars"];
  };
  "/api/2/user/columns": {
    /**
     * @description Returns the default columns for the given user. Admin permission will be required to get columns for a user
     *  other than the currently logged in user.
     */
    get: operations["defaultColumns"];
    /**
     * @description Sets the default columns for the given user.  Admin permission will be required to get columns for a user
     *  other than the currently logged in user.
     */
    put: operations["setColumns"];
    /**
     * @description Reset the default columns for the given user to the system default. Admin permission will be required to get
     *  columns for a user other than the currently logged in user.
     */
    delete: operations["resetColumns"];
  };
  "/api/2/user/duplicated/count": {
    /**
     * @description Returns the number of users whose accounts are duplicated.
     *  Duplicated means that the user has an account in more than one directory
     *  and either more than one account is active or the only active account does not belong to the directory
     *  with the highest priority.
     *  The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory
     *  is added, removed, enabled, disabled, or synchronized.
     *  A System Administrator can also flush the cache manually.
     *  Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
     */
    get: operations["getDuplicatedUsersCount"];
  };
  "/api/2/user/duplicated/list": {
    /**
     * @description Returns duplicated users mapped to their directories with an indication if their accounts are active or not.
     *  Duplicated means that the user has an account in more than one directory and either more than one account is active
     *  or the only active account does not belong to the directory with the highest priority.
     *  The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory
     *  is added, removed, enabled, disabled, or synchronized.
     *  A System Administrator can also flush the cache manually.
     *  Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
     */
    get: operations["getDuplicatedUsersMapping"];
  };
  "/api/2/user/password": {
    /** @description Modify user password. */
    put: operations["changeUserPassword"];
  };
  "/api/2/user/permission/search": {
    /**
     * @description Returns a list of active users that match the search string and have all specified permissions for the project or issue.<br>
     *  This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global ADMIN or SYSADMIN rights.<br>
     *  This endpoint can cause serious performance issues and will be removed in Jira 9.0.
     */
    get: operations["findUsersWithAllPermissions"];
  };
  "/api/2/user/picker": {
    /** @description Returns a list of users matching query with highlighting. */
    get: operations["findUsersForPicker"];
  };
  "/api/2/user/properties/": {
    /** @description Returns the keys of all properties for the user identified by the key or by the id. */
    get: operations["getPropertiesKeys"];
  };
  "/api/2/user/properties/{propertyKey}": {
    /**
     * @description Returns the value of the property with a given key from the user identified by the key or by the id. The user who retrieves
     *  the property is required to have permissions to read the user.
     */
    get: operations["getProperty"];
    /**
     * @description Sets the value of the specified user's property.
     *  <p>
     *  You can use this resource to store a custom data against the user identified by the key or by the id. The user
     *  who stores the data is required to have permissions to administer the user.
     *  </p>
     */
    put: operations["setProperty"];
    /**
     * @description Removes the property from the user identified by the key or by the id. Ths user removing the property is required
     *  to have permissions to administer the user.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        propertyKey: string;
      };
    };
  };
  "/api/2/user/search": {
    /** @description Returns a list of users that match the search string. This resource cannot be accessed anonymously. */
    get: operations["findUsers"];
  };
  "/api/2/user/session/{username}": {
    delete: operations["deleteSession"];
    parameters: {
      path: {
        username: string;
      };
    };
  };
  "/api/2/user/viewissue/search": {
    /**
     * @description Returns a list of active users that match the search string. This resource cannot be accessed anonymously
     *  and requires the Browse Users global permission.
     *  Given an issue key this resource will provide a list of users that match the search string and have
     *  the browse issue permission for the issue provided.
     */
    get: operations["findUsersWithBrowsePermission"];
  };
  "/api/2/version": {
    /** @description Retrieve paginated collection of versions matching given query optionally filtered by given project IDs. */
    get: operations["getPaginatedVersions"];
    /** @description Create a version via POST. */
    post: operations["createVersion"];
  };
  "/api/2/version/remotelink": {
    /** @description Returns the remote version links for a given global ID. */
    get: operations["getRemoteVersionLinks"];
  };
  "/api/2/version/{id}": {
    /** @description Returns a project version. */
    get: operations["getVersion"];
    /**
     * @description Modify a version via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
     *  is not present, it is silently ignored.
     */
    put: operations["updateVersion"];
    /** @description Delete a project version. */
    delete: operations["delete"];
    parameters: {
      path: {
        /** @description The version to delete */
        id: string;
      };
    };
  };
  "/api/2/version/{id}/mergeto/{moveIssuesTo}": {
    /** @description Merge versions */
    put: operations["merge"];
    parameters: {
      path: {
        /**
         * @description The version to set fixVersion to on issues where the deleted version is the fix version,
         *                      If null then the fixVersion is removed.
         */
        moveIssuesTo: string;
        /** @description The version that will be merged to version {@code moveIssuesTo} and removed */
        id: string;
      };
    };
  };
  "/api/2/version/{id}/move": {
    /**
     * @description Modify a version's sequence within a project.
     *  <p/>
     *  The move version bean has 2 alternative field value pairs:
     *  <dl>
     *  <dt>position</dt><dd>An absolute position, which may have a value of 'First', 'Last', 'Earlier' or 'Later'</dd>
     *  <dt>after</dt><dd>A version to place this version after.  The value should be the self link of another version</dd>
     *  </dl>
     */
    post: operations["moveVersion"];
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
  };
  "/api/2/version/{id}/relatedIssueCounts": {
    /** @description Returns a bean containing the number of fixed in and affected issues for the given version. */
    get: operations["getVersionRelatedIssues"];
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
  };
  "/api/2/version/{id}/removeAndSwap": {
    /** @description Delete a project version. */
    post: operations["delete"];
    parameters: {
      path: {
        /** @description The version to delete */
        id: string;
      };
    };
  };
  "/api/2/version/{id}/unresolvedIssueCount": {
    /** @description Returns the number of unresolved issues for the given version */
    get: operations["getVersionUnresolvedIssues"];
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
  };
  "/api/2/version/{versionId}/remotelink": {
    /** @description Returns the remote version links associated with the given version ID. */
    get: operations["getRemoteVersionLinksByVersionId"];
    /**
     * @description Create a remote version link via POST.  The link's global ID will be taken from the
     *  JSON payload if provided; otherwise, it will be generated.
     */
    post: operations["createOrUpdateRemoteVersionLink"];
    /** @description Delete all remote version links for a given version ID. */
    delete: operations["deleteRemoteVersionLinksByVersionId"];
    parameters: {
      path: {
        /** @description The version for which to delete ALL existing remote version links */
        versionId: string;
      };
    };
  };
  "/api/2/version/{versionId}/remotelink/{globalId}": {
    /** @description A REST sub-resource representing a remote version link */
    get: operations["getRemoteVersionLink"];
    /**
     * @description Create a remote version link via POST.  The link's global ID will be taken from the
     *  JSON payload if provided; otherwise, it will be generated.
     */
    post: operations["createOrUpdateRemoteVersionLink"];
    /** @description Delete a specific remote version link with the given version ID and global ID. */
    delete: operations["deleteRemoteVersionLink"];
    parameters: {
      path: {
        /** @description The version ID of the remote link */
        versionId: string;
        /** @description The global ID of the remote link */
        globalId: string;
      };
    };
  };
  "/api/2/workflow": {
    /**
     * @description Returns all workflows. The lastModifiedDate is returned in Jira Complete Date/Time Format (dd/MMM/yy h:mm by default),
     *  but can also be returned as a relative date.
     */
    get: operations["getAllWorkflows"];
  };
  "/api/2/workflow/api/2/transitions/{id}/properties": {
    /** @description Return the property or properties associated with a transition. */
    get: operations["getProperties"];
    /**
     * @description Update/add new property to a transition. Trying to update a property that does
     *  not exist will result in a new property being added.
     */
    put: operations["updateProperty"];
    /**
     * @description Add a new property to a transition. Trying to add a property that already
     *  exists will fail.
     */
    post: operations["createProperty"];
    /**
     * @description Delete a property from the passed transition on the passed workflow. It is not an error to delete a property that
     *  does not exist.
     */
    delete: operations["deleteProperty"];
    parameters: {
      path: {
        /** @description the ID of the transition within the workflow. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme": {
    /**
     * @description Create a new workflow scheme.
     *  <p/>
     *  The body contains a representation of the new scheme. Values not passed are assumed to be set to their defaults.
     */
    post: operations["createScheme"];
  };
  "/api/2/workflowscheme/{id}": {
    /** @description Returns the requested workflow scheme to the caller. */
    get: operations["getById"];
    /**
     * @description Update the passed workflow scheme.
     *  <p/>
     *  The body of the request is a representation of the workflow scheme. Values not passed are assumed to indicate
     *  no change for that field.
     *  <p/>
     *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft
     *  should be created and/or updated when the actual scheme cannot be edited (e.g. when the scheme is being used by
     *  a project). Values not appearing the body will not be touched.
     */
    put: operations["update"];
    /** @description Delete the passed workflow scheme. */
    delete: operations["deleteScheme"];
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/createdraft": {
    /** @description Create a draft for the passed scheme. The draft will be a copy of the state of the parent. */
    post: operations["createDraftForParent"];
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/default": {
    /** @description Return the default workflow from the passed workflow scheme. */
    get: operations["getDefault"];
    /**
     * @description Set the default workflow for the passed workflow scheme.
     *  <p/>
     *  The passed representation can have its
     *  updateDraftIfNeeded flag set to true to indicate that the draft should be created/updated when the actual scheme
     *  cannot be edited.
     */
    put: operations["updateDefault"];
    /** @description Remove the default workflow from the passed workflow scheme. */
    delete: operations["deleteDefault"];
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/draft": {
    /** @description Returns the requested draft workflow scheme to the caller. */
    get: operations["getDraftById"];
    /**
     * @description Update a draft workflow scheme. The draft will created if necessary.
     *  <p/>
     *  The body is a representation of the workflow scheme. Values not passed are assumed to indicate no change for that field.
     */
    put: operations["updateDraft"];
    /** @description Delete the passed draft workflow scheme. */
    delete: operations["deleteDraftById"];
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/draft/default": {
    /** @description Return the default workflow from the passed draft workflow scheme to the caller. */
    get: operations["getDraftDefault"];
    /** @description Set the default workflow for the passed draft workflow scheme. */
    put: operations["updateDraftDefault"];
    /** @description Remove the default workflow from the passed draft workflow scheme. */
    delete: operations["deleteDraftDefault"];
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/draft/issuetype/{issueType}": {
    /** @description Returns the issue type mapping for the passed draft workflow scheme. */
    get: operations["getDraftIssueType"];
    /**
     * @description Set the issue type mapping for the passed draft scheme.
     *  <p/>
     *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that
     *  the draft should be created/updated when the actual scheme cannot be edited.
     */
    put: operations["setDraftIssueType"];
    /** @description Remove the specified issue type mapping from the draft scheme. */
    delete: operations["deleteDraftIssueType"];
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/draft/workflow": {
    /** @description Returns the draft workflow mappings or requested mapping to the caller. */
    get: operations["getDraftWorkflow"];
    /**
     * @description Update the draft scheme to include the passed mapping.
     *  <p/>
     *  The body is a representation of the workflow mapping.
     *  Values not passed are assumed to indicate no change for that field.
     */
    put: operations["updateDraftWorkflowMapping"];
    /** @description Delete the passed workflow from the draft workflow scheme. */
    delete: operations["deleteDraftWorkflowMapping"];
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/issuetype/{issueType}": {
    /** @description Returns the issue type mapping for the passed workflow scheme. */
    get: operations["getIssueType"];
    /**
     * @description Set the issue type mapping for the passed scheme.
     *  <p/>
     *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that
     *  the draft should be created/updated when the actual scheme cannot be edited.
     */
    put: operations["setIssueType"];
    /** @description Remove the specified issue type mapping from the scheme. */
    delete: operations["deleteIssueType"];
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the scheme. */
        id: number;
      };
    };
  };
  "/api/2/workflowscheme/{id}/workflow": {
    /** @description Returns the workflow mappings or requested mapping to the caller for the passed scheme. */
    get: operations["getWorkflow"];
    /**
     * @description Update the scheme to include the passed mapping.
     *  <p/>
     *  The body is a representation of the workflow mapping.
     *  Values not passed are assumed to indicate no change for that field.
     *  <p/>
     *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft
     *  should be created/updated when the actual scheme cannot be edited.
     */
    put: operations["updateWorkflowMapping"];
    /** @description Delete the passed workflow from the workflow scheme. */
    delete: operations["deleteWorkflowMapping"];
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
  };
  "/api/2/worklog/deleted": {
    /**
     * @description Returns worklogs id and delete time of worklogs that was deleted since given time.
     *  The returns set of worklogs is limited to 1000 elements.
     *  This API will not return worklogs deleted during last minute.
     */
    get: operations["getIdsOfWorklogsDeletedSince"];
  };
  "/api/2/worklog/list": {
    /**
     * @description Returns worklogs for given worklog ids. Only worklogs to which the calling user has permissions, will be included in the result.
     *  The returns set of worklogs is limited to 1000 elements.
     */
    post: operations["getWorklogsForIds"];
  };
  "/api/2/worklog/updated": {
    /**
     * @description Returns worklogs id and update time of worklogs that was updated since given time.
     *  The returns set of worklogs is limited to 1000 elements.
     *  This API will not return worklogs updated during last minute.
     */
    get: operations["getIdsOfWorklogsModifiedSince"];
  };
  "/auth/1/session": {
    /**
     * @description Returns information about the currently authenticated user's session. If the caller is not authenticated they
     *  will get a 401 Unauthorized status code.
     */
    get: operations["currentUser"];
    /**
     * @description Creates a new session for a user in Jira. Once a session has been successfully created it can be used to access
     *  any of Jira's remote APIs and also the web UI by passing the appropriate HTTP Cookie header.
     *  <p>
     *  Note that it is generally preferrable to use HTTP BASIC authentication with the REST API. However, this resource
     *  may be used to mimic the behaviour of Jira's log-in page (e.g. to display log-in errors to a user).
     */
    post: operations["login"];
    /** @description Logs the current user out of Jira, destroying the existing session, if any. */
    delete: operations["logout"];
  };
  "/auth/1/websudo": {
    /** @description This method invalidates the any current WebSudo session. */
    delete: operations["release"];
  };
}

export type webhooks = Record<string, never>;

export type components = Record<string, never>;

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * @description Returns the value of the property with a given key from the user identified by the key or by the id. The user who retrieves
   *  the property is required to have permissions to read the user.
   */
  getProperty: {
    parameters: {
      query?: {
        /** @description key of the user whose property is to be returned */
        userKey?: string;
        /** @description username of the user whose property is to be returned */
        username?: string;
      };
      path: {
        propertyKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the properties that are displayed on the "General Configuration > Advanced Settings" page. */
  getAdvancedSettings: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Modify an application property via PUT. The "value" field present in the PUT will override the existing value. */
  setPropertyViaRestfulTable: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all ApplicationRoles in the system. Will also return an ETag header containing a version hash of the
   *  collection of ApplicationRoles.
   */
  getAll: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates the ApplicationRoles with the passed data if the version hash is the same as the server.
   *  Only the groups and default groups setting of the role may be updated. Requests to change the key
   *  or the name of the role will be silently ignored. It is acceptable to pass only the roles that are updated
   *  as roles that are present in the server but not in data to update with, will not be deleted.
   */
  putBulk: {
    parameters: {
      header?: {
        "If-Match"?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the ApplicationRole with passed key if it exists. */
  get: {
    parameters: {
      path: {
        /** @description the key of the role to update. */
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates the ApplicationRole with the passed data. Only the groups and default groups setting of the
   *  role may be updated. Requests to change the key or the name of the role will be silently ignored.
   *  <p>
   *  Optional: If versionHash is passed through the If-Match header the request will be rejected if not the
   *  same as server
   */
  put: {
    parameters: {
      header?: {
        /** @description the hash of the version to update. Optional Param */
        "If-Match"?: string;
      };
      path: {
        /** @description the key of the role to update. */
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the meta information for an attachments, specifically if they are enabled and the maximum upload size
   *  allowed.
   */
  getAttachmentMeta: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the meta-data for an attachment, including the URI of the actual attached file. */
  getAttachment: {
    parameters: {
      path: {
        /** @description id of the attachment to remove */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove an attachment from an issue. */
  removeAttachment: {
    parameters: {
      path: {
        /** @description id of the attachment to remove */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Tries to expand an attachment. Output is human-readable and subject to change. */
  expandForHumans: {
    parameters: {
      path: {
        /** @description the id of the attachment to expand. */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Tries to expand an attachment. Output is raw and should be backwards-compatible through the course of time. */
  expandForMachines: {
    parameters: {
      path: {
        /** @description the id of the attachment to expand. */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns auditing records filtered using provided parameters */
  getRecords: {
    parameters: {
      query?: {
        /** @description - the number of record from which search starts */
        offset?: number;
        /** @description - maximum number of returned results (if is limit is <= 0 or > 1000, it will be set do default value: 1000) */
        limit?: number;
        /** @description - text query; each record that will be returned must contain the provided text in one of its fields */
        filter?: string;
        /**
         * @description - timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty
         *                only records that where created in the same moment or after the 'from' timestamp will be provided in response
         */
        from?: string;
        /**
         * @description - timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty
         *                only records that where created in the same moment or earlier than the 'to' timestamp will be provided in response
         */
        to?: string;
        /** @description - list of project ids to look for */
        projectIds?: string;
        /** @description - list of user ids to look for */
        userIds?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Store a record in audit log */
  addRecord: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all system avatars of the given type. */
  getAllSystemAvatars: {
    parameters: {
      path: {
        /** @description the avatar type */
        type: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates temporary avatar */
  storeTemporaryAvatar: {
    parameters: {
      query?: {
        /** @description name of file being uploaded */
        filename?: string;
        /** @description size of file */
        size?: number;
      };
      path: {
        /** @description the avatar type */
        type: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Converts temporary avatar into a real avatar */
  createAvatarFromTemporary: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description request current index from node (the request is processed asynchronously) */
  requestCurrentIndexFromNode: {
    parameters: {
      path: {
        nodeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the node from the cluster if state of node is OFFLINE. */
  deleteNode: {
    parameters: {
      path: {
        nodeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Change the node's state to offline if the node is reporting as active, but is not alive.
   *  Don't use this method as an equivalent of running ./stop-jira.sh. This method doesn't shut down
   *  a node, but only changes its state, so that other nodes don't communicate with it.
   */
  changeNodeStateToOffline: {
    parameters: {
      path: {
        nodeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getAllNodes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  approveUpgrade: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  cancelUpgrade: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  acknowledgeErrors: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  setReadyToUpgrade: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getState: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the keys of all properties for the user identified by the key or by the id. */
  getPropertiesKeys: {
    parameters: {
      query?: {
        /** @description key of the user whose properties are to be returned */
        userKey?: string;
        /** @description username of the user whose properties are to be returned */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Sets the value of the specified user's property.
   *  <p>
   *  You can use this resource to store a custom data against the user identified by the key or by the id. The user
   *  who stores the data is required to have permissions to administer the user.
   *  </p>
   */
  setProperty: {
    parameters: {
      query?: {
        /** @description key of the user whose property is to be set */
        userKey?: string;
        /** @description username of the user whose property is to be set */
        username?: string;
      };
      path: {
        propertyKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Delete a property from the passed transition on the passed workflow. It is not an error to delete a property that
   *  does not exist.
   */
  deleteProperty: {
    parameters: {
      query?: {
        /** @description the name of the property to add. */
        key?: string;
        /** @description the name of the workflow to use. */
        workflowName?: string;
        /** @description the type of workflow to use. Can either be "live" or "draft". */
        workflowMode?: string;
      };
      path: {
        /** @description the ID of the transition within the workflow. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Create a component via POST. */
  createComponent: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns paginated list of filtered active components */
  getPaginatedComponents: {
    parameters: {
      query?: {
        /** @description the index of the first components to return */
        startAt?: number;
        /** @description the maximum number of components to return */
        maxResults?: number;
        /** @description the string that components names will be matched with */
        query?: string;
        /** @description the set of project ids to filter components */
        projectIds?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a project component. */
  getComponent: {
    parameters: {
      path: {
        /** @description The component to delete. */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Modify a component via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
   *  is not present, it is silently ignored.
   *  <p>
   *  If leadUserName is an empty string ("") the component lead will be removed.
   */
  updateComponent: {
    parameters: {
      path: {
        /** @description The component to delete. */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete a project version. */
  delete: {
    parameters: {
      path: {
        /** @description The version to delete */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns counts of issues related to this component. */
  getComponentRelatedIssues: {
    parameters: {
      path: {
        /** @description a String containing the component id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the information if the optional features in Jira are enabled or disabled. If the time tracking is enabled,
   *  it also returns the detailed information about time tracking configuration.
   */
  getConfiguration: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a full representation of the Custom Field Option that has the given id. */
  getCustomFieldOption: {
    parameters: {
      path: {
        /** @description a String containing an Custom Field Option id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getCustomFields: {
    parameters: {
      query?: {
        startAt?: number;
        maxResults?: number;
        search?: string;
        projectIds?: string;
        screenIds?: string;
        types?: string;
        sortOrder?: string;
        sortColumn?: string;
        lastValueUpdate?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  bulkDeleteCustomFields: {
    parameters: {
      query?: {
        ids?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns custom field's options defined in a given context composed of projects and issue types.
   *  <p>
   *  If the projects and issue types match more than one context or the context for such a combination does not exist then no options are returned.
   */
  getCustomFieldOptions: {
    parameters: {
      query?: {
        /** @description a list of projects in a context. */
        projectIds?: string;
        /** @description a list of issue types in a context. */
        issueTypeIds?: string;
        /** @description a string used to filter options. An option matches the query if any word in option's name starts with the given query. */
        query?: string;
        /** @description a limit of results. */
        maxResults?: number;
        /** @description the page of options to return. */
        page?: number;
      };
      path: {
        /** @description id of a custom field. */
        customFieldId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all dashboards, optionally filtering them. */
  list: {
    parameters: {
      query?: {
        /**
         * @description an optional filter that is applied to the list of dashboards. Valid values include
         *                         <code>"favourite"</code> for returning only favourite dashboards, and <code>"my"</code> for returning
         *                         dashboards that are owned by the calling user.
         */
        filter?: string;
        /**
         * @description the index of the first dashboard to return (0-based). must be 0 or a multiple of
         *                         <code>maxResults</code>
         */
        startAt?: number;
        /**
         * @description a hint as to the maximum number of dashboards to return in each call. Note that the
         *                         Jira server reserves the right to impose a <code>maxResults</code> limit that is lower than the value that a
         *                         client provides, dues to lack of resources or any other condition. When this happens, your results will be
         *                         truncated. Callers should always check the returned <code>maxResults</code> to determine the value that is
         *                         effectively being used.
         */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a single dashboard. */
  getDashboard: {
    parameters: {
      path: {
        /** @description the dashboard id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates a zip file containing email templates at local home and returns the file. */
  downloadEmailTemplates: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Extracts given zip file to temporary templates folder. If the folder already exists it will replace it's content */
  uploadEmailTemplates: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Replaces the current email templates pack with previously uploaded one, if exists. */
  applyEmailTemplates: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Replaces the current email templates pack with default templates, which are copied over from Jira binaries. */
  revertEmailTemplatesToDefault: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of root templates mapped with Event Types. The list can be used to decide which test emails to send. */
  getEmailTypes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all fields, both System and Custom */
  getFields: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates a custom field using a definition (object encapsulating custom field data) */
  createCustomField: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates a new filter, and returns newly created filter.
   *  Currently sets permissions just using the users default sharing permissions
   */
  createFilter: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the default share scope of the logged-in user. */
  getDefaultShareScope: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Sets the default share scope of the logged-in user.
   *  <p>
   *  Available values are: AUTHENTICATED (for sharing with all logged-in users) and PRIVATE (for no shares).
   */
  setDefaultShareScope: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the favourite filters of the logged-in user. */
  getFavouriteFilters: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a filter given an id */
  getFilter: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
      };
      path: {
        /** @description the id of the filter being looked up */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates an existing filter, and returns its new value.
   *  <p>
   *  The following properties of a filter can be updated: 'jql', 'name', 'description'.
   *  Additionally, administrators can also update the 'owner' field.
   *  To get, set or unset 'favourite', use rest/api/1.0/filters/{id}/favourite with GET, PUT and DELETE methods instead.
   *  </p>
   */
  editFilter: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
      };
      path: {
        /** @description the id of the filter being looked up */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete a filter. */
  deleteFilter: {
    parameters: {
      path: {
        /** @description the id of the filter being looked up */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the default columns for the given user. Admin permission will be required to get columns for a user
   *  other than the currently logged in user.
   */
  defaultColumns: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Sets the default columns for the given user.  Admin permission will be required to get columns for a user
   *  other than the currently logged in user.
   */
  setColumns: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Reset the default columns for the given user to the system default. Admin permission will be required to get
   *  columns for a user other than the currently logged in user.
   */
  resetColumns: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all share permissions of the given filter. */
  getSharePermissions: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds a share permissions to the given filter. Adding a global permission removes all previous permissions from the filter. */
  addSharePermission: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Removes a share permissions from the given filter. */
  deleteSharePermission: {
    parameters: {
      path: {
        id: number;
        "permission-id": number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a single share permission of the given filter. */
  getSharePermission: {
    parameters: {
      path: {
        permissionId: number;
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns REST representation for the requested group. Allows to get list of active users belonging to the
   *  specified group and its subgroups if "users" expand option is provided. You can page through users list by using
   *  indexes in expand param. For example to get users from index 10 to index 15 use "users[10:15]" expand value. This
   *  will return 6 users (if there are at least 16 users in this group). Indexes are 0-based and inclusive.
   *  <p>
   *  This resource is deprecated, please use group/member API instead.
   */
  getGroup: {
    parameters: {
      query?: {
        /** @description A name of requested group. */
        groupname?: string;
        /** @description List of fields to expand. Currently only available expand is "users". */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates a group by given group parameter
   *  <p>
   *  Returns REST representation for the requested group.
   */
  createGroup: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Deletes a group by given group parameter.
   *  <p>
   *  Returns no content
   */
  removeGroup: {
    parameters: {
      query?: {
        /** @description (mandatory) The name of the group to delete. */
        groupname?: string;
        /**
         * @description If you delete a group and content is restricted to that group, the content will be hidden from all users.
         *  To prevent this, use this parameter to specify a different group to transfer the restrictions (comments and worklogs only) to.
         */
        swapGroup?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description This resource returns a <a href="#pagination">paginated</a> list of users who are members of the specified group and its subgroups.
   *  Users in the page are ordered by user names. User of this resource is required to have sysadmin or admin permissions.
   */
  getUsersFromGroup: {
    parameters: {
      query?: {
        /** @description a name of the group for which members will be returned. */
        groupname?: string;
        /** @description inactive users will be included in the response if set to true. */
        includeInactiveUsers?: boolean;
        /** @description the index of the first user in group to return (0 based). */
        startAt?: number;
        /** @description the maximum number of users to return (max 50). */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Adds given user to a group.
   *  <p>
   *  Returns the current state of the group.
   */
  addUserToGroup: {
    parameters: {
      query?: {
        /** @description A name of requested group. */
        groupname?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Removes given user from a group.
   *  <p>
   *  Returns no content
   */
  removeUserFromGroup: {
    parameters: {
      query?: {
        /** @description A name of requested group. */
        groupname?: string;
        /** @description User to remove from a group */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns groups with substrings matching a given query. This is mainly for use with
   *  the group picker, so the returned groups contain html to be used as picker suggestions.
   *  The groups are also wrapped in a single response object that also contains a header for
   *  use in the picker, specifically <i>Showing X of Y matching groups</i>.
   *  <p>
   *  The number of groups returned is limited by the system property "jira.ajax.autocomplete.limit"
   *  <p>
   *  The groups will be unique and sorted.
   */
  findGroups: {
    parameters: {
      query?: {
        /** @description a String to match groups agains */
        query?: string;
        exclude?: string;
        maxResults?: number;
        userName?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of users and groups matching query with highlighting. This resource cannot be accessed
   *  anonymously.
   */
  findUsersAndGroups: {
    parameters: {
      query?: {
        /** @description A string used to search username, Name or e-mail address */
        query?: string;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 1000. If
         *                     you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
        showAvatar?: boolean;
        /** @description The custom field id, if this request comes from a custom field, such as a user picker. Optional. */
        fieldId?: string;
        /**
         * @description The list of project ids to further restrict the search
         *                     This parameter can occur multiple times to pass in multiple project ids.
         *                     Comma separated value is not supported.
         *                     This parameter is only used when fieldId is present.
         */
        projectId?: string;
        /**
         * @description The list of issue type ids to further restrict the search.
         *                     This parameter can occur multiple times to pass in multiple issue type ids.
         *                     Comma separated value is not supported.
         *                     Special values such as -1 (all standard issue types), -2 (all subtask issue types) are supported.
         *                     This parameter is only used when fieldId is present.
         */
        issueTypeId?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Lists available index snapshots absolute paths with timestamps.
   *  <p>
   *  Only System Administrator can request listing index snapshots.
   */
  listIndexSnapshot: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Tries to start taking an index snapshot if no other snapshot creation process is in progress.
   *  Performs a cleanup of index snapshots directory so only a limited number of most recent snapshots are persisted.
   *  If another snapshot creation process is in progress, returns 409 without waiting for the other process to complete.
   *  <p>
   *  Only System Administrator can request creation of snapshot. There is no guarantee as to the time after which the snapshot will be available.
   */
  createIndexSnapshot: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Answers true if index snapshot creation is currently running.
   *  <p>
   *  Only System Administrator can request current snapshot creation status.
   */
  isIndexSnapshotRunning: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Summarizes index condition of current node.
   *  <p/>
   *  Returned data consists of:
   *  <ul>
   *  <li><code>nodeId</code> - Node identifier.</li>
   *  <li><code>reportTime</code> - Time of this report creation.</li>
   *  <li><code>issueIndex</code> - Summary of issue index status.</li>
   *  <li><code>replicationQueues</code> - Map of index replication queues, where
   *  keys represent nodes from which replication operations came from.</li>
   *  </ul>
   *  <p/>
   *  <code>issueIndex</code> can contain:
   *  <ul>
   *  <li><code>indexReadable</code> - If <code>false</code> the end point failed to read data from issue index
   *  (check Jira logs for detailed stack trace), otherwise <code>true</code>.
   *  When <code>false</code> other fields of <code>issueIndex</code> can be not visible.</li>
   *  <li><code>countInDatabase</code> - Count of issues found in database.</li>
   *  <li><code>countInIndex</code> - Count of issues found while querying index.</li>
   *  <li><code>lastUpdatedInDatabase</code> - Time of last update of issue found in database.</li>
   *  <li><code>lastUpdatedInIndex</code> - Time of last update of issue found while querying index.</li>
   *  </ul>
   *  <p/>
   *  <code>replicationQueues</code>'s map values can contain:
   *  <ul>
   *  <li><code>lastConsumedOperation</code> - Last executed index replication operation by current node from sending node's queue.</li>
   *  <li><code>lastConsumedOperation.id</code> - Identifier of the operation.</li>
   *  <li><code>lastConsumedOperation.replicationTime</code> - Time when the operation was sent to other nodes.</li>
   *  <li><code>lastOperationInQueue</code> - Last index replication operation in sending node's queue.</li>
   *  <li><code>lastOperationInQueue.id</code> - Identifier of the operation.</li>
   *  <li><code>lastOperationInQueue.replicationTime</code> - Time when the operation was sent to other nodes.</li>
   *  <li><code>queueSize</code> - Number of operations in queue from sending node to current node.</li>
   *  </ul>
   */
  getIndexSummary: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates an issue or a sub-task from a JSON representation.
   *  <p/>
   *  The fields that can be set on create, in either the fields parameter or the update parameter can be determined
   *  using the <b>/rest/api/2/issue/createmeta</b> resource.
   *  If a field is not configured to appear on the create screen, then it will not be in the createmeta, and a field
   *  validation error will occur if it is submitted.
   *  <p/>
   *  Creating a sub-task is similar to creating a regular issue, with two important differences:
   *  <ul>
   *  <li>the <code>issueType</code> field must correspond to a sub-task issue type (you can use
   *  <code>/issue/createmeta</code> to discover sub-task issue types), and</li>
   *  <li>you must provide a <code>parent</code> field in the issue create request containing the id or key of the
   *  parent issue.</li>
   *  <li>The <code>updateHistory</code> param adds the project that this issue is created in, to the current user's project history,
   *  if set to true (by default, the project history is not updated).</li>
   *  <li>You can view the project history in the Jira application, via the Projects dropdown.</li>
   *  </ul>
   */
  createIssue: {
    parameters: {
      query?: {
        /** @description if true then the user's project history is updated */
        updateHistory?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Archives a list of issues. */
  archiveIssues: {
    parameters: {
      query?: {
        /**
         * @description send the email with notification that the issue was updated to users that watch it.
         *                     Admin or project admin permissions are required to disable the notification.
         */
        notifyUsers?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates issues or sub-tasks from a JSON representation.
   *  <p/>
   *  Creates many issues in one bulk operation.
   *  <p/>
   *  Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:
   *  {@link IssueResource#createIssue(boolean, IssueUpdateBean)}}}
   */
  createIssues: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the metadata for issue types used for creating issues.
   *  Data will not be returned if the user does not have permission to create issues in that project.
   */
  getCreateIssueMetaProjectIssueTypes: {
    parameters: {
      query?: {
        /** @description the page offset, if not specified then defaults to 0 */
        startAt?: number;
        /** @description how many results on the page should be included. Defaults to 50. */
        maxResults?: number;
      };
      path: {
        /** @description to get metadata for */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the metadata for issue types used for creating issues.
   *  Data will not be returned if the user does not have permission to create issues in that project.
   */
  getCreateIssueMetaFields: {
    parameters: {
      query?: {
        /** @description the page offset, if not specified then defaults to 0 */
        startAt?: number;
        /** @description how many results on the page should be included. Defaults to 50. */
        maxResults?: number;
      };
      path: {
        /** @description to get metadata for */
        issueTypeId: string;
        /** @description to get metadata for */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns suggested issues which match the auto-completion query for the user which executes this request. This REST
   *  method will check the user's history and the user's browsing context and select this issues, which match the query.
   */
  getIssuePickerResource: {
    parameters: {
      query?: {
        /** @description the query. */
        query?: string;
        /** @description the JQL in context of which the request is executed. Only issues which match this JQL query will be included in results. */
        currentJQL?: string;
        /** @description the key of the issue in context of which the request is executed. The issue which is in context will not be included in the auto-completion result, even if it matches the query. */
        currentIssueKey?: string;
        /** @description the id of the project in context of which the request is executed. Suggested issues will be only from this project. */
        currentProjectId?: string;
        /** @description if set to false, subtasks will not be included in the list. */
        showSubTasks?: boolean;
        /** @description if set to false and request is executed in context of a subtask, the parent issue will not be included in the auto-completion result, even if it matches the query. */
        showSubTaskParent?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a full representation of the issue for the given issue key.
   *  <p>
   *  An issue JSON consists of the issue key, a collection of fields,
   *  a link to the workflow transition sub-resource, and (optionally) the HTML rendered values of any fields that support it
   *  (e.g. if wiki syntax is enabled for the description or comments).
   *  <p>
   *  The <code>fields</code> param (which can be specified multiple times) gives a comma-separated list of fields
   *  to include in the response. This can be used to retrieve a subset of fields.
   *  A particular field can be excluded by prefixing it with a minus.
   *  <p>
   *  By default, all (<code>*all</code>) fields are returned in this get-issue resource. Note: the default is different
   *  when doing a jql search -- the default there is just navigable fields (<code>*navigable</code>).
   *  <ul>
   *  <li><code>*all</code> - include all fields</li>
   *  <li><code>*navigable</code> - include just navigable fields</li>
   *  <li><code>summary,comment</code> - include just the summary and comments</li>
   *  <li><code>-comment</code> - include everything except comments (the default is <code>*all</code> for get-issue)</li>
   *  <li><code>*all,-comment</code> - include everything except comments</li>
   *  </ul>
   *  <p>
   *  The {@code properties} param is similar to {@code fields} and specifies a comma-separated list of issue
   *  properties to include. Unlike {@code fields}, properties are not included by default. To include them all
   *  send {@code ?properties=*all}. You can also include only specified properties or exclude some properties
   *  with a minus (-) sign.
   *  <p>
   *  <ul>
   *  <li>{@code *all} - include all properties</li>
   *  <li>{@code *all, -prop1} - include all properties except {@code prop1} </li>
   *  <li>{@code prop1, prop1} - include {@code prop1} and {@code prop2} properties </li>
   *  </ul>
   *  </p>
   *  <p/>
   *  Jira will attempt to identify the issue by the <code>issueIdOrKey</code> path parameter. This can be an issue id,
   *  or an issue key. If the issue cannot be found via an exact match, Jira will also look for the issue in a case-insensitive way, or
   *  by looking to see if the issue was moved. In either of these cases, the request will proceed as normal (a 302 or other redirect
   *  will <b>not</b> be returned). The issue key contained in the response will indicate the current value of issue's key.
   *  <p/>
   *  The <code>expand</code> param is used to include, hidden by default, parts of response. This can be used to include:
   *  <ul>
   *  <li><code>renderedFields</code> - field values in HTML format</li>
   *  <li><code>names</code> - display name of each field</li>
   *  <li><code>schema</code> - schema for each field which describes a type of the field</li>
   *  <li><code>transitions</code> - all possible transitions for the given issue</li>
   *  <li><code>operations</code> - all possibles operations which may be applied on issue</li>
   *  <li><code>editmeta</code> - information about how each field may be edited. It contains field's schema as well.</li>
   *  <li><code>changelog</code> - history of all changes of the given issue</li>
   *  <li><code>versionedRepresentations</code> -
   *  REST representations of all fields. Some field may contain more recent versions. RESET representations are numbered.
   *  The greatest number always represents the most recent version. It is recommended that the most recent version is used.
   *  version for these fields which provide a more recent REST representation.
   *  After including <code>versionedRepresentations</code> "fields" field become hidden.</li>
   *  </ul>
   */
  getIssue: {
    parameters: {
      query?: {
        /** @description the list of fields to return for the issue. By default, all fields are returned. */
        fields?: string;
        expand?: string;
        /** @description the list of properties to return for the issue. By default no properties are returned. */
        properties?: string;
        updateHistory?: boolean;
      };
      path: {
        /** @description the issue id or key to update (i.e. JRA-1330) */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Edits an issue from a JSON representation.
   *  <p/>
   *  The issue can either be updated by setting explicit the field value(s)
   *  or by using an operation to change the field value.
   *  <p/>
   *  The fields that can be updated, in either the fields parameter or the update parameter, can be determined
   *  using the <b>/rest/api/2/issue/{issueIdOrKey}/editmeta</b> resource.<br>
   *  If a field is not configured to appear on the edit screen, then it will not be in the editmeta, and a field
   *  validation error will occur if it is submitted.
   *  <p/>
   *  Specifying a "field_id": field_value in the "fields" is a shorthand for a "set" operation in the "update" section.<br>
   *  Field should appear either in "fields" or "update", not in both.
   */
  editIssue: {
    parameters: {
      query?: {
        /**
         * @description send the email with notification that the issue was updated to users that watch it.
         *                      Admin or project admin permissions are required to disable the notification.
         */
        notifyUsers?: boolean;
      };
      path: {
        /** @description the issue id or key to update (i.e. JRA-1330) */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Delete an issue.
   *  <p/>
   *  If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue.
   *  You cannot delete an issue without its subtasks also being deleted.
   */
  deleteIssue: {
    parameters: {
      query?: {
        /**
         * @description a String of true or false indicating that any subtasks should also be deleted.  If the
         *                        issue has no subtasks this parameter is ignored.  If the issue has subtasks and this parameter is missing or false,
         *                        then the issue will not be deleted and an error will be returned.
         */
        deleteSubtasks?: string;
      };
      path: {
        /** @description the issue id or key to update (i.e. JRA-1330) */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Archives an issue. */
  archiveIssue: {
    parameters: {
      query?: {
        /**
         * @description send the email with notification that the issue was updated to users that watch it.
         *                      Admin or project admin permissions are required to disable the notification.
         */
        notifyUsers?: boolean;
      };
      path: {
        /** @description Issue id or issue key */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Assigns an issue to a user.
   *  You can use this resource to assign issues when the user submitting the request has the assign permission but not the
   *  edit issue permission.
   *  If the name is "-1" automatic assignee is used.  A null name will remove the assignee.
   */
  assign: {
    parameters: {
      path: {
        /** @description a String containing an issue key */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Add one or more attachments to an issue.
   *  <p>
   *  This resource expects a multipart post. The media-type multipart/form-data is defined in RFC 1867. Most client
   *  libraries have classes that make dealing with multipart posts simple. For instance, in Java the Apache HTTP Components
   *  library provides a
   *  <a href="http://hc.apache.org/httpcomponents-client-ga/httpmime/apidocs/org/apache/http/entity/mime/MultipartEntity.html">MultiPartEntity</a>
   *  that makes it simple to submit a multipart POST.
   *  <p>
   *  In order to protect against XSRF attacks, because this method accepts multipart/form-data, it has XSRF protection
   *  on it.  This means you must submit a header of X-Atlassian-Token: no-check with the request, otherwise it will be
   *  blocked.
   *  <p>
   *  The name of the multipart/form-data parameter that contains attachments must be "file"
   *  <p>
   *  A simple example to upload a file called "myfile.txt" to issue REST-123:
   *  <pre>curl -D- -u admin:admin -X POST -H "X-Atlassian-Token: no-check" -F "file=@myfile.txt" http://myhost/rest/api/2/issue/TEST-123/attachments</pre>
   */
  addAttachment: {
    parameters: {
      path: {
        /** @description the issue that you want to add the attachments to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all comments for an issue.
   *  <p>
   *  Results can be ordered by the "created" field which means the date a comment was added.
   *  </p>
   */
  getComments: {
    parameters: {
      query?: {
        /** @description the page offset, if not specified then defaults to 0 */
        startAt?: number;
        /** @description how many results on the page should be included. Defaults to 50. */
        maxResults?: number;
        /** @description ordering of the results. */
        orderBy?: string;
        /** @description optional flags: renderedBody (provides body rendered in HTML) */
        expand?: string;
      };
      path: {
        /** @description a string containing the issue id or key the comment will be added to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds a new comment to an issue. */
  addComment: {
    parameters: {
      query?: {
        /** @description optional flags: renderedBody (provides body rendered in HTML) */
        expand?: string;
      };
      path: {
        /** @description a string containing the issue id or key the comment will be added to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a single comment. */
  getComment: {
    parameters: {
      query?: {
        /** @description optional flags: renderedBody (provides body rendered in HTML) */
        expand?: string;
      };
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
        /** @description the ID of the comment to request */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Updates an existing comment using its JSON representation. */
  updateComment: {
    parameters: {
      query?: {
        /** @description optional flags: renderedBody (provides body rendered in HTML) */
        expand?: string;
      };
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
        /** @description the ID of the comment to request */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes an existing comment . */
  deleteComment: {
    parameters: {
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
        /** @description the ID of the comment to request */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  setPinComment: {
    parameters: {
      path: {
        issueIdOrKey: string;
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the meta data for editing an issue.
   *  <p/>
   *  The fields in the editmeta correspond to the fields in the edit screen for the issue.
   *  Fields not in the screen will not be in the editmeta.
   */
  getEditIssueMeta: {
    parameters: {
      path: {
        /** @description the issue whose edit meta data you want to view */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Sends a notification (email) to the list or recipients defined in the request. */
  notify: {
    parameters: {
      path: {
        /** @description a string containing the issue id or key the comment will be added to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all pinned to the issue comments. */
  getPinnedComments: {
    parameters: {
      path: {
        /** @description of the issue the comment belongs to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description A REST sub-resource representing the remote issue links on the issue. */
  getRemoteIssueLinks: {
    parameters: {
      query?: {
        /**
         * @description The id of the remote issue link to be returned.  If null (not provided) all remote links for the
         *                      issue are returned.
         *                      <p>For a fullexplanation of Issue Link fields please refer to
         *                      <a href="https://developer.atlassian.com/display/JIRADEV/Fields+in+Remote+Issue+Links">https://developer.atlassian.com/display/JIRADEV/Fields+in+Remote+Issue+Links</a></p>
         */
        globalId?: string;
      };
      path: {
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates or updates a remote issue link from a JSON representation. If a globalId is provided and a remote issue link
   *  exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
   */
  createOrUpdateRemoteIssueLink: {
    parameters: {
      path: {
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the remote issue link with the given global id on the issue. */
  deleteRemoteIssueLinkByGlobalId: {
    parameters: {
      query?: {
        /** @description the global id of the remote issue link */
        globalId?: string;
      };
      path: {
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Get the remote issue link with the given id on the issue. */
  getRemoteIssueLinkById: {
    parameters: {
      path: {
        /** @description the id of the remote issue link */
        linkId: string;
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Updates a remote issue link from a JSON representation. Any fields not provided are set to null. */
  updateRemoteIssueLink: {
    parameters: {
      path: {
        /** @description the id of the remote issue link */
        linkId: string;
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the remote issue link with the given id on the issue. */
  deleteRemoteIssueLinkById: {
    parameters: {
      path: {
        /** @description the id of the remote issue link */
        linkId: string;
        /** @description the issue to create the remote issue link for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Restores an archived issue. */
  restoreIssue: {
    parameters: {
      query?: {
        /**
         * @description send the email with notification that the issue was updated to users that watch it.
         *                      Admin or project admin permissions are required to disable the notification.
         */
        notifyUsers?: boolean;
      };
      path: {
        /** @description Issue id or issue key */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns an issue's subtask list */
  getSubTasks: {
    parameters: {
      path: {
        /** @description The parent issue's key or id */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  canMoveSubTask: {
    parameters: {
      path: {
        /** @description The parent issue's key or id */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Reorders an issue's subtasks by moving the subtask at index "from"
   *  to index "to".
   */
  moveSubTasks: {
    parameters: {
      path: {
        /** @description The parent issue's key or id */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Get a list of the transitions possible for this issue by the current user, along with fields that are required and their types.
   *  <p/>
   *  Fields will only be returned if <code>expand=transitions.fields</code>.
   *  <p/>
   *  The fields in the metadata correspond to the fields in the transition screen for that transition.
   *  Fields not in the screen will not be in the metadata.
   */
  getTransitions: {
    parameters: {
      query?: {
        transitionId?: string;
      };
      path: {
        /** @description the issue you want to transition */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Perform a transition on an issue.
   *  When performing the transition you can update or set other issue fields.
   *  <p/>
   *  The fields that can be set on transtion, in either the fields parameter or the update parameter can be determined
   *  using the <b>/rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields</b> resource.
   *  If a field is not configured to appear on the transition screen, then it will not be in the transition metadata, and a field
   *  validation error will occur if it is submitted.
   *  <p>
   *  The <code>updateHistory</code> param adds the issues retrieved by this method to the current user's issue history,
   *  if set to true (by default, the issue history does not include issues retrieved via the REST API).
   *  You can view the issue history in the Jira application, via the Issues dropdown or by using the
   *  <code>lastViewed</code> JQL field in an issue search.
   */
  doTransition: {
    parameters: {
      path: {
        /** @description the issue you want to transition */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description A REST sub-resource representing the voters on the issue. */
  getVotes: {
    parameters: {
      path: {
        /** @description the issue to view voting information for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Cast your vote in favour of an issue. */
  addVote: {
    parameters: {
      path: {
        /** @description the issue to view voting information for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove your vote from an issue. (i.e. "unvote") */
  removeVote: {
    parameters: {
      path: {
        /** @description the issue to view voting information for */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the list of watchers for the issue with the given key. */
  getIssueWatchers: {
    parameters: {
      path: {
        /** @description a String containing an issue key. */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds a user to an issue's watcher list. */
  addWatcher: {
    parameters: {
      path: {
        /** @description a String containing an issue key. */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Removes a user from an issue's watcher list. */
  removeWatcher: {
    parameters: {
      query?: {
        /** @description a String containing the name of the user to remove from the watcher list. Must not be null. */
        username?: string;
      };
      path: {
        /** @description a String containing an issue key. */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all work logs for an issue. <br/>
   *  <strong>Note:</strong> Work logs won't be returned if the Log work field is hidden for the project.
   */
  getIssueWorklog: {
    parameters: {
      path: {
        /** @description a string containing the issue id or key the worklog will be added to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds a new worklog entry to an issue. */
  addWorklog: {
    parameters: {
      query?: {
        /**
         * @description (optional) allows you to provide specific instructions to update the remaining time estimate of the issue.  Valid values are
         *                        <ul>
         *                        <li>"new" - sets the estimate to a specific value</li>
         *                        <li>"leave"- leaves the estimate as is</li>
         *                        <li>"manual" - specify a specific amount to increase remaining estimate by</li>
         *                        <li>"auto"- Default option.  Will automatically adjust the value based on the new timeSpent specified on the worklog</li> </ul>
         */
        adjustEstimate?: string;
        /** @description (required when "new" is selected for adjustEstimate) the new value for the remaining estimate field. e.g. "2d" */
        newEstimate?: string;
        /** @description (required when "manual" is selected for adjustEstimate) the amount to reduce the remaining estimate by e.g. "2d" */
        reduceBy?: string;
      };
      path: {
        /** @description a string containing the issue id or key the worklog will be added to */
        issueIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a specific worklog. <br/>
   *  <strong>Note:</strong> The work log won't be returned if the Log work field is hidden for the project.
   */
  getWorklog: {
    parameters: {
      path: {
        /** @description a string containing the issue id or key the worklog belongs to */
        issueIdOrKey: string;
        /** @description id of the worklog to be deleted */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates an existing worklog entry.
   *  <p>Note that:</p>
   *  <ul>
   *      <li>Fields possible for editing are: comment, visibility, started, timeSpent and timeSpentSeconds.</li>
   *      <li>Either timeSpent or timeSpentSeconds can be set.</li>
   *      <li>Fields which are not set will not be updated.</li>
   *      <li>For a request to be valid, it has to have at least one field change.</li>
   *  </ul>
   */
  updateWorklog: {
    parameters: {
      query?: {
        /**
         * @description (optional) allows you to provide specific instructions to update the remaining time estimate of the issue.  Valid values are
         *                        <ul>
         *                        <li>"new" - sets the estimate to a specific value</li>
         *                        <li>"leave"- leaves the estimate as is</li>
         *                        <li>"auto"- Default option.  Will automatically adjust the value based on the new timeSpent specified on the worklog</li> </ul>
         */
        adjustEstimate?: string;
        /** @description (required when "new" is selected for adjustEstimate) the new value for the remaining estimate field. */
        newEstimate?: string;
      };
      path: {
        /** @description a string containing the issue id or key the worklog belongs to */
        issueIdOrKey: string;
        /** @description id of the worklog to be deleted */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes an existing worklog entry. */
  deleteWorklog: {
    parameters: {
      query?: {
        /**
         * @description (optional) allows you to provide specific instructions to update the remaining time estimate of the issue.  Valid values are
         *                        <ul>
         *                        <li>"new" - sets the estimate to a specific value</li>
         *                        <li>"leave"- leaves the estimate as is</li>
         *                        <li>"manual" - specify a specific amount to increase remaining estimate by</li>
         *                        <li>"auto"- Default option.  Will automatically adjust the value based on the new timeSpent specified on the worklog</li> </ul>
         */
        adjustEstimate?: string;
        /** @description (required when "new" is selected for adjustEstimate) the new value for the remaining estimate field. e.g. "2d" */
        newEstimate?: string;
        /** @description (required when "manual" is selected for adjustEstimate) the amount to increase the remaining estimate by e.g. "2d" */
        increaseBy?: string;
      };
      path: {
        /** @description a string containing the issue id or key the worklog belongs to */
        issueIdOrKey: string;
        /** @description id of the worklog to be deleted */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates an issue link between two issues.
   *  The user requires the link issue permission for the issue which will be linked to another issue.
   *  The specified link type in the request is used to create the link and will create a link from the first issue
   *  to the second issue using the outward description. It also create a link from the second issue to the first issue using the
   *  inward description of the issue link type.
   *  It will add the supplied comment to the first issue. The comment can have a restriction who can view it.
   *  If group is specified, only users of this group can view this comment, if roleLevel is specified only users who have the specified role can view this comment.
   *  The user who creates the issue link needs to belong to the specified group or have the specified role.
   */
  linkIssues: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns an issue link with the specified id. */
  getIssueLink: {
    parameters: {
      path: {
        /** @description the issue link id. */
        linkId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Deletes an issue link with the specified id.
   *  To be able to delete an issue link you must be able to view both issues and must have the link issue permission
   *  for at least one of the issues.
   */
  deleteIssueLink: {
    parameters: {
      path: {
        /** @description the issue link id. */
        linkId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of available issue link types, if issue linking is enabled.
   *  Each issue link type has an id, a name and a label for the outward and inward link relationship.
   */
  getIssueLinkTypes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Create a new issue link type. */
  createIssueLinkType: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns for a given issue link type id all information about this issue link type. */
  getIssueLinkType: {
    parameters: {
      path: {
        issueLinkTypeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Update the specified issue link type. */
  updateIssueLinkType: {
    parameters: {
      path: {
        issueLinkTypeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the specified issue link type. */
  deleteIssueLinkType: {
    parameters: {
      path: {
        issueLinkTypeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all issue security schemes that are defined. */
  getIssueSecuritySchemes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the issue security scheme for project. */
  getIssueSecurityScheme: {
    parameters: {
      path: {
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all issue types visible to the user */
  getIssueAllTypes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates an issue type from a JSON representation and adds the issue newly created issue type to the default issue
   *  type scheme.
   */
  createIssueType: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns paginated list of filtered issue types */
  getPaginatedIssueTypes: {
    parameters: {
      query?: {
        /** @description the index of the first issue type to return */
        startAt?: number;
        /** @description the maximum number of issue type to return */
        maxResults?: number;
        /** @description the string that issue type names will be matched with */
        query?: string;
        /** @description the set of project ids to filter issue types */
        projectIds?: string;
      };
      header?: {
        "X-Requested-With"?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the issue type mapping for the passed workflow scheme. */
  getIssueType: {
    parameters: {
      query?: {
        /**
         * @description when true indicates that a scheme's draft, if it exists, should be queried instead of
         *                             the scheme itself.
         */
        returnDraftIfExists?: boolean;
      };
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Updates the specified issue type from a JSON representation. */
  updateIssueType: {
    parameters: {
      path: {
        /** @description a String containing an issue type id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove the specified issue type mapping from the scheme. */
  deleteIssueType: {
    parameters: {
      query?: {
        /**
         * @description when true will create and return a draft when the workflow scheme cannot be edited
         *                             (e.g. when it is being used by a project).
         */
        updateDraftIfNeeded?: boolean;
      };
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of all alternative issue types for the given issue type id. The list will contain these issues types, to which
   *  issues assigned to the given issue type can be migrated. The suitable alternatives are issue types which are assigned
   *  to the same workflow, the same field configuration and the same screen scheme.
   */
  getAlternativeIssueTypes: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because
   *  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from
   *  which the client parses the JSON from.
   *  <p>
   *  Creating a temporary avatar is part of a 3-step process in uploading a new
   *  avatar for a user: upload, crop, confirm. This endpoint allows you to use a multipart upload
   *  instead of sending the image directly as the request body.
   *  </p>
   *  <p>
   *  You *must* use "avatar" as the name of the upload parameter:</p>
   *  <p/>
   *  <pre>
   *  curl -c cookiejar.txt -X POST -u admin:admin -H "X-Atlassian-Token: no-check" \
   *    -F "avatar=@mynewavatar.png;type=image/png" \
   *    'http://localhost:8090/jira/rest/api/2/user/avatar/temporary?username=admin'
   *  </pre>
   */
  storeTemporaryAvatarUsingMultiPart: {
    parameters: {
      query?: {
        /** @description Username */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the keys of all properties for the issue type identified by the id. */
  getPropertyKeys: {
    parameters: {
      path: {
        /** @description the issue type from which the keys will be returned */
        issueTypeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of all issue type schemes visible to the user (must be admin).
   *  <p>
   *      All issue types associated with the scheme will only be returned if an additional query parameter is provided:
   *      <code>expand=schemes.issueTypes</code>.
   *  </p>
   *  <p>
   *      Similarly, the default issue type associated with the scheme (if one exists) will only be returned if
   *      additional an query parameter is provided: <code>expand=schemes.defaultIssueType</code>.
   *  </p>
   *  <p>
   *      Note that both query parameters can be used together: <code>expand=schemes.issueTypes,schemes.defaultIssueType</code>.
   *  </p>
   */
  getAllIssueTypeSchemes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates an issue type scheme from a JSON representation. (Admin required) */
  createIssueTypeScheme: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a full representation of the issue type scheme that has the given id (must be admin). */
  getIssueTypeScheme: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme to remove. */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Updates the specified issue type scheme from a JSON representation. (Admin required) */
  updateIssueTypeScheme: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme to remove. */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Deletes the specified issue type scheme. Any projects associated with this IssueTypeScheme will be automatically
   *  associated with the global default IssueTypeScheme. (Admin required)
   */
  deleteIssueTypeScheme: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme to remove. */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description For the specified issue type scheme, returns all of the associated projects. (Admin required) */
  getAssociatedProjects: {
    parameters: {
      query?: {
        /** @description the parameters to expand on the returned projects; defaults to none. */
        expand?: string;
      };
      path: {
        /** @description the id of the issue type scheme whose project associations we're removing */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Associates the given projects with the specified issue type scheme. Any existing project-associations the issue
   *  type scheme has will be overwritten.  (Admin required)
   */
  setProjectAssociationsForScheme: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme whose project associations we're removing */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds additional projects to those already associated with the specified issue type scheme. (Admin required) */
  addProjectAssociationsToScheme: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme whose project associations we're removing */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Removes all project associations for the specified issue type scheme. These projects revert to an association with
   *  the default/global issue type scheme.(Admin required)
   */
  removeAllProjectAssociations: {
    parameters: {
      path: {
        /** @description the id of the issue type scheme whose project associations we're removing */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description For the specified issue type scheme, removes the given project association . This project reverts to an association
   *  with the default/global issue type scheme.(Admin required)
   */
  removeProjectAssociation: {
    parameters: {
      path: {
        /** @description the id or key of the project that is to be un-associated with the issue type scheme */
        projIdOrKey: string;
        /** @description the id of the issue type scheme whose project association we're removing */
        schemeId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the auto complete data required for JQL searches. */
  getAutoComplete: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns auto complete suggestions for JQL search. */
  getFieldAutoCompleteForQueryString: {
    parameters: {
      query?: {
        /** @description the field name for which the suggestions are generated. */
        fieldName?: string;
        /** @description the portion of the field value that has already been provided by the user. */
        fieldValue?: string;
        /** @description the predicate for which the suggestions are generated. Suggestions are generated only for: "by", "from" and "to". */
        predicateName?: string;
        /** @description the portion of the predicate value that has already been provided by the user. */
        predicateValue?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  validate: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  isAppMonitoringEnabled: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  setAppMonitoringEnabled: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  isIpdMonitoringEnabled: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  areMetricsExposed: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getAvailableMetrics: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  start: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  stop: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all permissions in the system and whether the currently logged in user has them. You can optionally provide a specific context to get permissions for
   *  (projectKey OR projectId OR issueKey OR issueId)
   *  <ul>
   *  <li> When no context supplied the project related permissions will return true if the user has that permission in ANY project </li>
   *  <li> If a project context is provided, project related permissions will return true if the user has the permissions in the specified project.
   *  For permissions that are determined using issue data (e.g Current Assignee), true will be returned if the user meets the permission criteria in ANY issue in that project </li>
   *  <li> If an issue context is provided, it will return whether or not the user has each permission in that specific issue</li>
   *  </ul>
   *  <p>
   *  NB: The above means that for issue-level permissions (EDIT_ISSUE for example), hasPermission may be true when no context is provided, or when a project context is provided,
   *  <b>but</b> may be false for any given (or all) issues. This would occur (for example) if Reporters were given the EDIT_ISSUE permission. This is because
   *  any user could be a reporter, except in the context of a concrete issue, where the reporter is known.
   *  </p>
   *  <p>
   *  Global permissions will still be returned for all scopes.
   *  </p>
   *  <p>
   *  Prior to version 6.4 this service returned project permissions with keys corresponding to com.atlassian.jira.security.Permissions.Permission constants.
   *  Since 6.4 those keys are considered deprecated and this service returns system project permission keys corresponding to constants defined in com.atlassian.jira.permission.ProjectPermissions.
   *  Permissions with legacy keys are still also returned for backwards compatibility, they are marked with an attribute deprecatedKey=true.
   *  The attribute is missing for project permissions with the current keys.
   *  </p>
   */
  getPermissions: {
    parameters: {
      query?: {
        /** @description - key of project to scope returned permissions for. */
        projectKey?: string;
        /** @description - id of project to scope returned permissions for. */
        projectId?: string;
        /** @description - key of the issue to scope returned permissions for. */
        issueKey?: string;
        /** @description - id of the issue to scope returned permissions for. */
        issueId?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns preference of the currently logged in user. Preference key must be provided as input parameter (key). The
   *  value is returned exactly as it is. If key parameter is not provided or wrong - status code 404. If value is
   *  found  - status code 200.
   */
  getPreference: {
    parameters: {
      query?: {
        /** @description - key of the preference to be returned. */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Sets preference of the currently logged in user. Preference key must be provided as input parameters (key). Value
   *  must be provided as post body. If key or value parameter is not provided - status code 404. If preference is set
   *  - status code 204.
   */
  setPreference: {
    parameters: {
      query?: {
        /** @description - key of the preference to be set. */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Removes preference of the currently logged in user. Preference key must be provided as input parameters (key). If
   *  key parameter is not provided or wrong - status code 404. If preference is unset - status code 204.
   */
  removePreference: {
    parameters: {
      query?: {
        /** @description - key of the preference to be removed. */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a user. This resource cannot be accessed anonymously. */
  getUser: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description user key */
        key?: string;
        /** @description whether deleted users should be returned (flag available to users with global ADMIN rights) */
        includeDeleted?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Modify user. The "value" fields present will override the existing value.
   *  Fields skipped in request will not be changed.
   */
  updateUser: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description user key */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Modify caller password. */
  changeMyPassword: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a <a href="#pagination">paginated</a> list of notification schemes. In order to access notification scheme, the calling user is
   *  required to have permissions to administer at least one project associated with the requested notification scheme. Each scheme contains
   *  a list of events and recipient configured to receive notifications for these events. Consumer should allow events without recipients to appear in response.
   *  The list is ordered by the scheme's name.
   *  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
   */
  getNotificationSchemes: {
    parameters: {
      query?: {
        /** @description the index of the first notification scheme to return (0 based). */
        startAt?: number;
        /** @description the maximum number of notification schemes to return (max 50). */
        maxResults?: number;
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Gets a notification scheme associated with the project.
   *  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
   */
  getNotificationScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the list of requirements for the current password policy. For example, "The password must have at least 10 characters.",
   *  "The password must not be similar to the user's name or email address.", etc.
   */
  getPasswordPolicy: {
    parameters: {
      query?: {
        /**
         * @description whether or not the user will be required to enter their current password.  Use
         *                        {@code false} (the default) if this is a new user or if an administrator is forcibly changing
         *                        another user's password.
         */
        hasOldPassword?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of statements explaining why the password policy would disallow a proposed password for a new user.
   *  <p>
   *  You can use this method to test the password policy validation. This could be done prior to an action
   *  where a new user and related password are created, using methods like the ones in
   *  <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/user/UserService.html">UserService</a>.
   *  For example, you could use this to validate a password in a create user form in the user interface, as the user enters it.<br/>
   *  The username and new password must be not empty to perform the validation.<br/>
   *  Note, this method will help you validate against the policy only. It won't check any other validations that might be performed
   *  when creating a new user, e.g. checking whether a user with the same name already exists.
   *  </p>
   */
  policyCheckCreateUser: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of statements explaining why the password policy would disallow a proposed new password for a user with an existing password.
   *  <p>
   *  You can use this method to test the password policy validation. This could be done prior to an action where the password
   *  is actually updated, using methods like <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ChangePassword.html">ChangePassword</a>
   *  or <a href="https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ResetPassword.html">ResetPassword</a>.
   *  For example, you could use this to validate a password in a change password form in the user interface, as the user enters it.<br/>
   *  The user must exist and the username and new password must be not empty, to perform the validation.<br/>
   *  Note, this method will help you validate against the policy only. It won't check any other validations that might be performed
   *  when submitting a password change/reset request, e.g. verifying whether the old password is valid.
   *  </p>
   */
  policyCheckUpdateUser: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all permissions that are present in the Jira instance - Global, Project and the global ones added by plugins */
  getAllPermissions: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of all permission schemes.
   *  <p>
   *  By default only shortened beans are returned. If you want to include permissions of all the schemes,
   *  then specify the <b>permissions</b> expand parameter. Permissions will be included also if you specify
   *  any other expand parameter.
   *  </p>
   */
  getPermissionSchemes: {
    parameters: {
      query?: {
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Create a new permission scheme.
   *  This method can create schemes with a defined permission set, or without.
   */
  createPermissionScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getSchemeAttribute: {
    parameters: {
      path: {
        /** @description permission scheme id */
        permissionSchemeId: number;
        /** @description permission scheme attribute key */
        attributeKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates or inserts the attribute for a permission scheme specified by permission scheme id.
   *  The attribute consists of the key and the value. The value will be converted to Boolean using Boolean#valueOf.
   */
  setSchemeAttribute: {
    parameters: {
      path: {
        /** @description permission scheme id */
        permissionSchemeId: number;
        /** @description permission scheme attribute key */
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a permission scheme identified by the given id. */
  getPermissionScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates a permission scheme.
   *  <p>
   *  If the permissions list is present then it will be set in the permission scheme, which basically means it will overwrite any permission grants that
   *  existed in the permission scheme. Sending an empty list will remove all permission grants from the permission scheme.
   *  </p>
   *  <p>
   *  To update just the name and description, do not send permissions list at all.
   *  </p>
   *  <p>
   *  To add or remove a single permission grant instead of updating the whole list at once use the <b>{schemeId}/permission/</b> resource.
   *  </p>
   */
  updatePermissionScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes a permission scheme identified by the given id. */
  deletePermissionScheme: {
    parameters: {
      path: {
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all permission grants of the given permission scheme. */
  getPermissionSchemeGrants: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates a permission grant in a permission scheme. */
  createPermissionGrant: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a permission grant identified by the given id. */
  getPermissionSchemeGrant: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        permissionId: number;
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes a permission grant from a permission scheme. */
  deletePermissionSchemeEntity: {
    parameters: {
      path: {
        permissionId: number;
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all issue priorities. */
  getPriorities: {
    parameters: {
      query?: {
        startAt?: number;
        maxResults?: number;
        query?: string;
        projectIds?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns an issue priority. */
  getPriority: {
    parameters: {
      path: {
        /** @description a String containing the priority id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all priority schemes.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=schemes.projectKeys</code>.
   */
  getPrioritySchemes: {
    parameters: {
      query?: {
        /** @description the page offset, if not specified then defaults to 0 */
        startAt?: number;
        /** @description how many results on the page should be included. Defaults to 100, maximum is 1000. */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates new priority scheme. */
  createPriorityScheme: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Gets a full representation of a priority scheme in JSON format.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
   */
  getPriorityScheme: {
    parameters: {
      path: {
        /** @description id of priority scheme to get */
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates a priority scheme.
   *  Update will be rejected if issue migration would be needed as a result of scheme update.
   *  Priority scheme update with migration is possible from the UI.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
   */
  updatePriorityScheme: {
    parameters: {
      path: {
        /** @description id of priority scheme to get */
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Deletes a priority scheme. All projects using deleted scheme will use default priority scheme afterwards.
   *
   *  Default priority scheme can't be deleted.
   */
  deletePriorityScheme: {
    parameters: {
      path: {
        /** @description id of priority scheme to get */
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all projects which are visible for the currently logged in user. If no user is logged in, it returns the
   *  list of projects that are visible when using anonymous access.
   */
  getAllProjects: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
        /** @description if this parameter is set then only projects recently accessed by the current user (if not logged in then based on HTTP session) will be returned (maximum count limited to the specified number but no more than 20). */
        recent?: number;
        /** @description whether to include archived projects in response, default: false */
        includeArchived?: boolean;
        /** @description whether to include only projects where current user can browse archive */
        browseArchive?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates a new project. */
  createProject: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all the project types defined on the Jira instance, not taking into account whether
   *  the license to use those project types is valid or not.
   */
  getAllProjectTypes: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the project type with the given key. */
  getProjectTypeByKey: {
    parameters: {
      path: {
        projectTypeKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the project type with the given key, if it is accessible to the logged in user.
   *  This takes into account whether the user is licensed on the Application that defines the project type.
   */
  getAccessibleProjectTypeByKey: {
    parameters: {
      path: {
        projectTypeKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Validates a project key. */
  getProject: {
    parameters: {
      query?: {
        /** @description the project key */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates a project.
   *  <p>
   *  Only non null values sent in JSON will be updated in the project.</p>
   *  <p>
   *  Values available for the assigneeType field are: "PROJECT_LEAD" and "UNASSIGNED".</p>
   */
  updateProject: {
    parameters: {
      query?: {
        /** @description the parameters to expand in returned project */
        expand?: string;
      };
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes a project. */
  deleteProject: {
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Archives a project. */
  archiveProject: {
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates an avatar for a project. This is step 3/3 of changing an avatar for a project:
   *
   *  <ul>
   *  <li>Upload (store temporary avatar)</li>
   *  <li>Crop (create avatar from temporary)</li>
   *  <li><b>Update (update project avatar)</b></li>
   *  </ul>
   */
  updateProjectAvatar: {
    parameters: {
      path: {
        /** @description project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes avatar */
  deleteAvatar: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
      };
      path: {
        /** @description database id for avatar */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all avatars which are visible for the currently logged in user. */
  getAllAvatars: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Contains a full representation of a the specified project's components. */
  getProjectComponents: {
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Restore an archived project.
   *  In case of success restored project should be re-indexed.
   */
  restoreProject: {
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Get all the ProjectRoles available in Jira. Currently this list is global. */
  getProjectRoles: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the details for a given project role in a project. */
  getProjectRole: {
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
        /** @description the project role id */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Updates a project role to include the specified actors (users or groups). Can be also used to clear roles to not include any users or groups.
   *  <p>
   *  For user actors, their usernames should be used.
   */
  setActors: {
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
        /** @description the project role id */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Adds an actor (user or group) to a project role.
   *  <p>
   *  For user actors, their usernames should be used.
   */
  addActorUsers: {
    parameters: {
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
        /** @description the project role id */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Deletes actors (users or groups) from a project role.
   *  <p>
   *  <ul>
   *  <li>Delete a user from the role: <code>/rest/api/2/project/{projectIdOrKey}/role/{roleId}?user={username}</code></li>
   *  <li>Delete a group from the role: <code>/rest/api/2/project/{projectIdOrKey}/role/{roleId}?group={groupname}</code></li>
   *  </ul>
   */
  deleteActor: {
    parameters: {
      query?: {
        /** @description the username of the user to remove from the project role */
        user?: string;
        /** @description the groupname to remove from the project role */
        group?: string;
      };
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
        /** @description the project role id */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Get all issue types with valid status values for a project */
  getAllStatuses: {
    parameters: {
      path: {
        /** @description Project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Updates the type of a project. */
  updateProjectType: {
    parameters: {
      path: {
        /** @description identity of the project to update */
        projectIdOrKey: string;
        /** @description The key of the new project type */
        newProjectTypeKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all versions for the specified project. Results are <a href="#pagination">paginated</a>.
   *  <p>
   *  Results can be ordered by the following fields:
   *  <ul>
   *  <li>sequence</li>
   *  <li>name</li>
   *  <li>startDate</li>
   *  <li>releaseDate</li>
   *  </ul>
   *  </p>
   */
  getProjectVersionsPaginated: {
    parameters: {
      query?: {
        /** @description the page offset, if not specified then defaults to 0 */
        startAt?: number;
        /** @description how many results on the page should be included. Defaults to 50. */
        maxResults?: number;
        /** @description ordering of the results. */
        orderBy?: string;
        /** @description the parameters to expand */
        expand?: string;
      };
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Contains a full representation of a the specified project's versions. */
  getProjectVersions: {
    parameters: {
      query?: {
        /** @description the parameters to expand */
        expand?: string;
      };
      path: {
        /** @description the project id or project key */
        projectIdOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Gets a permission scheme assigned with a project. */
  getAssignedPermissionScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Assigns a permission scheme with a project. */
  assignPermissionScheme: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Gets a full representation of a priority scheme in JSON format used by specified project.
   *  User must be global administrator or project administrator.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
   */
  getAssignedPriorityScheme: {
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Assigns project with priority scheme.
   *  Priority scheme assign with migration is possible from the UI.
   *
   *  Operation will fail if migration is needed as a result of operation eg. there are issues with priorities invalid in the destination scheme.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
   */
  assignPriorityScheme: {
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Unassigns project from priority scheme.
   *
   *  Operation will fail for defualt priority scheme, project is not found or project is not associated with provided priority scheme.
   *
   *  All project keys associated with the priority scheme will only be returned if additional query parameter is provided <code>expand=projectKeys</code>.
   */
  unassignPriorityScheme: {
    parameters: {
      path: {
        /** @description key or id of the project */
        projectKeyOrId: string;
        /** @description object that contains an id of the scheme */
        schemeId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all security levels for the project that the current logged in user has access to.
   *  If the user does not have the Set Issue Security permission, the list will be empty.
   */
  getSecurityLevelsForProject: {
    parameters: {
      path: {
        /** @description - key or id of project to list the security levels for */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the workflow scheme that is associated with requested project. */
  getWorkflowSchemeForProject: {
    parameters: {
      path: {
        /** @description the key or id of the project. */
        projectKeyOrId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns all project categories */
  getAllProjectCategories: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Create a project category via POST. */
  createProjectCategory: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Contains a representation of a project category in JSON format. */
  getProjectCategoryById: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Modify a project category via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
   *  is not present, it is silently ignored.
   */
  updateProjectCategory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete a project category. */
  removeProjectCategory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of projects visible to the user where project name and/or key is matching the given query.
   *  <p>
   *  Passing an empty (or whitespace only) query will match no projects. The project matches will
   *  contain a field with the query highlighted.
   *  <p>
   *  The number of projects returned can be controlled by passing a value for "maxResults", but a hard limit of no
   *  more than 100 projects is enforced. The projects are wrapped in a single response object that contains
   *  a header for use in the picker, specifically <i>Showing X of Y matching projects</i> and the total number
   *  of matches for the query.
   */
  searchForProjects: {
    parameters: {
      query?: {
        /** @description a sequence of characters expected to be found in the word-prefix of project name and/or key. */
        query?: string;
        /** @description maximum number of matches to return. Zero means a default limit of 100 and negative numbers return no results. */
        maxResults?: number;
        /** @description if true, and the query is empty, the method will return first results limited to the value of "maxResults" or default limit of 100. */
        allowEmptyQuery?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.
   *  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404
   *  indicating that no reindex has taken place.
   */
  getReindexInfo: {
    parameters: {
      query?: {
        /**
         * @description the id of an indexing task you wish to obtain details on.  If omitted, then defaults to the standard behaviour and
         *                returns information on the active reindex task, or the last task to run if no reindex is taking place. .  If there is no
         *                reindexing task with that id then a 404 is returned.
         */
        taskId?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Kicks off a reindex.  Need Admin permissions to perform this reindex. */
  reindex: {
    parameters: {
      query?: {
        /** @description Case insensitive String indicating type of reindex.  If omitted, then defaults to BACKGROUND_PREFERRED. */
        type?: string;
        /** @description Indicates that comments should also be reindexed. Not relevant for foreground reindex, where comments are always reindexed. */
        indexComments?: boolean;
        /** @description Indicates that changeHistory should also be reindexed. Not relevant for foreground reindex, where changeHistory is always reindexed. */
        indexChangeHistory?: boolean;
        /** @description Indicates that worklogs should also be reindexed. Not relevant for foreground reindex, where worklogs are always reindexed. */
        indexWorklogs?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Reindexes one or more individual issues.  Indexing is performed synchronously - the call returns when indexing of
   *  the issues has completed or a failure occurs.
   *  <p>
   *  Use either explicitly specified issue IDs or a JQL query to select issues to reindex.
   */
  reindexIssues: {
    parameters: {
      query?: {
        /** @description the IDs or keys of one or more issues to reindex. */
        issueId?: string;
        /** @description Indicates that comments should also be reindexed. */
        indexComments?: boolean;
        /** @description Indicates that changeHistory should also be reindexed. */
        indexChangeHistory?: boolean;
        /** @description Indicates that worklogs should also be reindexed. */
        indexWorklogs?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.
   *  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404
   *  indicating that no reindex has taken place.
   */
  getReindexProgress: {
    parameters: {
      query?: {
        /**
         * @description the id of an indexing task you wish to obtain details on.  If omitted, then defaults to the standard behaviour and
         *                returns information on the active reindex task, or the last task to run if no reindex is taking place. .  If there is no
         *                reindexing task with that id then a 404 is returned.
         */
        taskId?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Executes any pending reindex requests.  Returns a JSON array containing the IDs of the reindex requests
   *  that are being processed.  Execution is asynchronous - progress of the returned tasks can be monitored through
   *  other REST calls.
   */
  processRequests: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Retrieves the progress of a multiple reindex requests.  Only reindex requests that actually exist will be returned
   *  in the results.
   */
  getProgressBulk: {
    parameters: {
      query?: {
        /** @description the reindex request IDs. */
        requestId?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns information about a user anonymization operation progress. */
  getProgress: {
    parameters: {
      query?: {
        /**
         * @description the id of a user anonymization task you wish to obtain details on.  If omitted, then defaults to
         *                the active anonymization task, or the last task that was run if no anonymization is taking place.
         */
        taskId?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all resolutions. */
  getResolutions: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns paginated list of filtered resolutions */
  getPaginatedResolutions: {
    parameters: {
      query?: {
        /** @description the index of the first status to return */
        startAt?: number;
        /** @description the maximum number of statuses to return */
        maxResults?: number;
        /** @description the string that status names will be matched with */
        query?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a resolution. */
  getResolution: {
    parameters: {
      path: {
        /** @description a String containing the resolution id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates a new ProjectRole to be available in Jira.
   *  The created role does not have any default actors assigned.
   */
  createProjectRole: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Get a specific ProjectRole available in Jira. */
  getProjectRolesById: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Fully updates a roles. Both name and description must be given. */
  fullyUpdateProjectRole: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Partially updates a roles name or description. */
  partialUpdateProjectRole: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes a role. May return 403 in the future */
  deleteProjectRole: {
    parameters: {
      query?: {
        /** @description if given, removes a role even if it is used in scheme by replacing the role with the given one */
        swap?: number;
      };
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Gets default actors for the given role. */
  getProjectRoleActorsForRole: {
    parameters: {
      path: {
        /** @description the role id to remove the actors from */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds default actors to the given role. The request data should contain a list of usernames or a list of groups to add. */
  addProjectRoleActorsToRole: {
    parameters: {
      path: {
        /** @description the role id to remove the actors from */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Removes default actor from the given role. */
  deleteProjectRoleActorsFromRole: {
    parameters: {
      query?: {
        /** @description if given, removes an actor from given role */
        user?: string;
        /** @description if given, removes an actor from given role */
        group?: string;
      };
      path: {
        /** @description the role id to remove the actors from */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Gets available field screens */
  getAllScreens: {
    parameters: {
      query?: {
        /** @description offset from which the response starts */
        startAt?: string;
        /** @description amount of field screens to return */
        maxResults?: string;
        expand?: string;
        search?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds field or custom field to the default tab */
  addFieldToDefaultScreen: {
    parameters: {
      path: {
        /** @description id of field / custom field */
        fieldId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Gets available fields for screen. i.e ones that haven't already been added. */
  getFieldsToAdd: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all tabs for the given screen */
  getAllTabs: {
    parameters: {
      query?: {
        /** @description the key of the project; this parameter is optional */
        projectKey?: string;
      };
      path: {
        /** @description id of screen */
        screenId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Creates tab for given screen */
  addTab: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Renames tab on given screen */
  renameTab: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Deletes tab to give screen */
  deleteTab: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Gets all fields for a given tab */
  getAllFields: {
    parameters: {
      query?: {
        /** @description the key of the project; this parameter is optional */
        projectKey?: string;
      };
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Adds field to the given tab. */
  addField: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Removes field from given tab */
  removeField: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Moves field on the given tab */
  moveField: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Update 'showWhenEmptyIndicator' for given field on screen */
  updateShowWhenEmptyIndicator: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        /** @description new value of 'showWhenEmptyIndicator' */
        newValue: boolean;
        /** @description id of field */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Moves tab position */
  moveTab: {
    parameters: {
      path: {
        /** @description id of screen */
        screenId: number;
        /** @description id of tab */
        tabId: number;
        /** @description position of tab */
        pos: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Searches for issues using JQL.
   *  <p>
   *  <b>Sorting</b>
   *  the <code>jql</code> parameter is a full <a href="http://confluence.atlassian.com/display/JIRA/Advanced+Searching">JQL</a>
   *  expression, and includes an <code>ORDER BY</code> clause.
   *  </p>
   *  <p>
   *  The <code>fields</code> param (which can be specified multiple times) gives a comma-separated list of fields
   *  to include in the response. This can be used to retrieve a subset of fields.
   *  A particular field can be excluded by prefixing it with a minus.
   *  <p>
   *  By default, only navigable (<code>*navigable</code>) fields are returned in this search resource. Note: the default is different
   *  in the get-issue resource -- the default there all fields (<code>*all</code>).
   *  <ul>
   *  <li><code>*all</code> - include all fields</li>
   *  <li><code>*navigable</code> - include just navigable fields</li>
   *  <li><code>summary,comment</code> - include just the summary and comments</li>
   *  <li><code>-description</code> - include navigable fields except the description (the default is <code>*navigable</code> for search)</li>
   *  <li><code>*all,-comment</code> - include everything except comments</li>
   *  </ul>
   *  <p>
   *  </p>
   *  <p><b>GET vs POST:</b>
   *  If the JQL query is too large to be encoded as a query param you should instead
   *  POST to this resource.
   *  </p>
   *  <p>
   *  <b>Expanding Issues in the Search Result:</b>
   *  It is possible to expand the issues returned by directly specifying the expansion on the expand parameter passed
   *  in to this resources.
   *  </p>
   *  <p>
   *  For instance, to expand the &quot;changelog&quot; for all the issues on the search result, it is neccesary to
   *  specify &quot;changelog&quot; as one of the values to expand.
   *  </p>
   */
  search: {
    parameters: {
      query?: {
        /** @description a JQL query string */
        jql?: string;
        /** @description the index of the first issue to return (0-based) */
        startAt?: number;
        /**
         * @description the maximum number of issues to return (defaults to 50). The maximum allowable value is
         *                       dictated by the Jira property 'jira.search.views.default.max'. If you specify a value that is higher than this
         *                       number, your search results will be truncated.
         */
        maxResults?: number;
        /** @description whether to validate the JQL query */
        validateQuery?: boolean;
        /** @description the list of fields to return for each issue. By default, all navigable fields are returned. */
        fields?: string;
        /** @description A comma-separated list of the parameters to expand. */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Performs a search using JQL. */
  searchUsingSearchRequest: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a full representation of the security level that has the given id. */
  getIssuesecuritylevel: {
    parameters: {
      path: {
        /** @description a String containing an issue security level id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns general information about the current Jira server. */
  getServerInfo: {
    parameters: {
      query?: {
        doHealthCheck?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Sets the base URL that is configured for this Jira instance. */
  setBaseURL: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the default system columns for issue navigator. Admin permission will be required. */
  getIssueNavigatorDefaultColumns: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Sets the default system columns for issue navigator. Admin permission will be required. */
  setIssueNavigatorDefaultColumns: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all statuses */
  getStatuses: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns paginated list of filtered statuses */
  getPaginatedStatuses: {
    parameters: {
      query?: {
        /** @description the index of the first status to return */
        startAt?: number;
        /** @description the maximum number of statuses to return */
        maxResults?: number;
        /** @description the string that status names will be matched with */
        query?: string;
        /** @description the list of project ids to filter statuses */
        projectIds?: string;
        /** @description the list of issue type ids to filter statuses */
        issueTypeIds?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a full representation of the Status having the given id or name. */
  getStatus: {
    parameters: {
      path: {
        /** @description a numeric Status id or a status name */
        idOrName: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of all status categories */
  getStatusCategories: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a full representation of the StatusCategory having the given id or key */
  getStatusCategory: {
    parameters: {
      path: {
        /** @description a numeric StatusCategory id or a status category key */
        idOrKey: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the list of all defined names for the default words "epic" and "sprint". */
  getAllTerminologyEntries: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Change epic/sprint names from {"originalName"} to {"newName"}. The {"newName"} will be displayed in Jira instead of {"originalName"}.
   *  <p>
   *  {"originalName"} must be equal to "epic" or "sprint".
   *  There can be only one entry per unique {"originalName"}.
   *  <p>
   *  {"newName"} can only consist of alphanumeric characters and spaces e.g. {"newName": "iteration number 2"}.
   *  <p>
   *  {"newName"} must be between 1 to 100 characters.
   *  It can't use the already defined {"newName"} values or <a href=https://confluence.atlassian.com/jiracoreserver/search-syntax-for-text-fields-939937723.html>restricted JQL words</a> .
   *  <p>
   *  To reset {"newName"} to the default value, enter the {"originalName"} value as the value for {"newName"}. For example, if you want to return to {"originalName": "sprint"}, enter {"newName": "sprint"}.
   */
  setTerminologyEntries: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns epic or sprint name as specified in the {originalName} path param. */
  getTerminologyEntry: {
    parameters: {
      path: {
        originalName: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  getAvatars: {
    parameters: {
      path: {
        type: string;
        owningObjectId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the result of the last upgrade task.
   *
   *  Returns {@link javax.ws.rs.core.Response#seeOther(java.net.URI)} if still running.
   */
  getUpgradeResult: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Runs any pending delayed upgrade tasks.  Need Admin permissions to do this. */
  runUpgradesNow: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Create user. By default created user will not be notified with email.
   *  If password field is not set then password will be randomly generated.
   */
  createUser: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Removes user and its references (like project roles associations, watches, history).
   *  <br>
   *  <br>
   *  <b>Note:</b> user references will not be removed if multiple User Directories are used and there is a user with
   *  the same name existing in another directory (shadowing user).
   */
  removeUser: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description user key */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns available accessibility personal settings along with `enabled` property
   *  that indicates the currently logged-in user preference.
   */
  getA11yPersonalSettings: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Validates user anonymization process. */
  validateUserAnonymization: {
    parameters: {
      query?: {
        /** @description the key of the user to validate anonymization for. */
        userKey?: string;
        /** @description Parameter used to include parts of the response. This can be used to include: affectedEntities. Affected entities will only be returned if <code>expand=affectedEntities</code>. */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Schedules a user anonymization process. Requires system admin permission. */
  scheduleUserAnonymization: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Validates user anonymization re-run process. */
  validateUserAnonymizationRerun: {
    parameters: {
      query?: {
        /** @description the key of the user to validate anonymization for */
        userKey?: string;
        /**
         * @description user key before anonymization, only needed when current value is anonymized.
         *                     If there is no old key, e.g. because the user was already created
         *                     using the new key generation strategy, provide a value equal to the current key.
         */
        oldUserKey?: string;
        /**
         * @description user name before anonymization, only needed when the current value is anonymized.
         *                     If there is no old name, provide a value equal to the current name.
         */
        oldUserName?: string;
        /** @description Parameter used to include parts of the response. This can be used to include: affectedEntities. Affected entities will only be returned if <code>expand=affectedEntities</code>. */
        expand?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Schedules a user anonymization process. Requires system admin permission. */
  scheduleUserAnonymizationRerun: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Removes stale user anonymization task, for scenarios when the node that was executing it is no longer alive.
   *  <p>
   *  <strong>Use it only after making sure that the parent node of the task is actually down, and not just having
   *  connectivity issues.</strong>
   */
  unlockAnonymization: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Add user to given application. Admin permission will be required to perform this operation. */
  addUserToApplication: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
        /** @description application key */
        applicationKey?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove user from given application. Admin permission will be required to perform this operation. */
  removeUserFromApplication: {
    parameters: {
      query?: {
        /** @description username */
        username?: string;
        /** @description application key */
        applicationKey?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of users that match the search string and can be assigned issues for all the given projects. */
  findBulkAssignableUsers: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description the keys of the projects we are finding assignable users for, comma-separated */
        projectKeys?: string;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 100.
         *                        If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of users that match the search string. This resource cannot be accessed anonymously.
   *  Please note that this resource should be called with an issue key when a list of assignable users is retrieved
   *  for editing.  For create only a project key should be supplied.  The list of assignable users may be incorrect
   *  if it's called with the project key for editing.
   */
  findAssignableUsers: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description the key of the project we are finding assignable users for */
        project?: string;
        /** @description the issue key for the issue being edited we need to find assignable users for. */
        issueKey?: string;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 100.
         *                    If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
        actionDescriptorId?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  updateUserAvatar: {
    parameters: {
      query?: {
        username?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns the number of users whose accounts are duplicated.
   *  Duplicated means that the user has an account in more than one directory
   *  and either more than one account is active or the only active account does not belong to the directory
   *  with the highest priority.
   *  The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory
   *  is added, removed, enabled, disabled, or synchronized.
   *  A System Administrator can also flush the cache manually.
   *  Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
   */
  getDuplicatedUsersCount: {
    parameters: {
      query?: {
        /** @description if set to true forces cache flush, user must be sysadmin for this parameter to have an effect. */
        flush?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns duplicated users mapped to their directories with an indication if their accounts are active or not.
   *  Duplicated means that the user has an account in more than one directory and either more than one account is active
   *  or the only active account does not belong to the directory with the highest priority.
   *  The data returned by this endpoint is cached for 10 minutes and the cache is flushed when any User Directory
   *  is added, removed, enabled, disabled, or synchronized.
   *  A System Administrator can also flush the cache manually.
   *  Related JAC ticket: https://jira.atlassian.com/browse/JRASERVER-68797
   */
  getDuplicatedUsersMapping: {
    parameters: {
      query?: {
        /** @description if set to true forces cache flush, user must be sysadmin for this parameter to have an effect. */
        flush?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Modify user password. */
  changeUserPassword: {
    parameters: {
      query?: {
        /** @description the username */
        username?: string;
        /** @description user key */
        key?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of active users that match the search string and have all specified permissions for the project or issue.<br>
   *  This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global ADMIN or SYSADMIN rights.<br>
   *  This endpoint can cause serious performance issues and will be removed in Jira 9.0.
   */
  findUsersWithAllPermissions: {
    parameters: {
      query?: {
        /** @description the username filter, list includes all users if unspecified */
        username?: string;
        /**
         * @description comma separated list of permissions for project or issue returned users must have, see
         *                     <a href="https://developer.atlassian.com/static/javadoc/jira/6.0/reference/com/atlassian/jira/security/Permissions.Permission.html">Permissions</a>
         *                     JavaDoc for the list of all possible permissions.
         */
        permissions?: string;
        /** @description the issue key for the issue for which returned users have specified permissions. */
        issueKey?: string;
        /** @description the optional project key to search for users with if no issueKey is supplied. */
        projectKey?: string;
        /** @description the index of the first user to return (0-based) */
        startAt?: number;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 1000.
         *                     If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of users matching query with highlighting. */
  findUsersForPicker: {
    parameters: {
      query?: {
        /** @description A string used to search username, Name or e-mail address */
        query?: string;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 1000.
         *                    If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
        showAvatar?: boolean;
        exclude?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a list of users that match the search string. This resource cannot be accessed anonymously. */
  findUsers: {
    parameters: {
      query?: {
        /** @description A query string used to search username, name or e-mail address */
        username?: string;
        /** @description the index of the first user to return (0-based) */
        startAt?: number;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 1000.
         *                         If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
        /** @description If true, then active users are included in the results (default true) */
        includeActive?: boolean;
        /** @description If true, then inactive users are included in the results (default false) */
        includeInactive?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  deleteSession: {
    parameters: {
      path: {
        username: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns a list of active users that match the search string. This resource cannot be accessed anonymously
   *  and requires the Browse Users global permission.
   *  Given an issue key this resource will provide a list of users that match the search string and have
   *  the browse issue permission for the issue provided.
   */
  findUsersWithBrowsePermission: {
    parameters: {
      query?: {
        /** @description the username filter, no users returned if left blank */
        username?: string;
        /** @description the issue key for the issue being edited we need to find viewable users for. */
        issueKey?: string;
        /** @description the optional project key to search for users with if no issueKey is supplied. */
        projectKey?: string;
        /**
         * @description the maximum number of users to return (defaults to 50). The maximum allowed value is 100.
         *                    If you specify a value that is higher than this number, your search results will be truncated.
         */
        maxResults?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Retrieve paginated collection of versions matching given query optionally filtered by given project IDs. */
  getPaginatedVersions: {
    parameters: {
      query?: {
        /** @description optional index of the first version to return */
        startAt?: number;
        /** @description optional maximum number of versions to return */
        maxResults?: number;
        /** @description optional string that version names will be matched with */
        query?: string;
        /** @description optional set of project IDs to filter versions with */
        projectIds?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Create a version via POST. */
  createVersion: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the remote version links for a given global ID. */
  getRemoteVersionLinks: {
    parameters: {
      query?: {
        /** @description the global ID of the remote resource that is linked to the versions */
        globalId?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a project version. */
  getVersion: {
    parameters: {
      query?: {
        expand?: string;
      };
      path: {
        /** @description The version to delete */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Modify a version via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field
   *  is not present, it is silently ignored.
   */
  updateVersion: {
    parameters: {
      path: {
        /** @description The version to delete */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Merge versions */
  merge: {
    parameters: {
      path: {
        /**
         * @description The version to set fixVersion to on issues where the deleted version is the fix version,
         *                      If null then the fixVersion is removed.
         */
        moveIssuesTo: string;
        /** @description The version that will be merged to version {@code moveIssuesTo} and removed */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Modify a version's sequence within a project.
   *  <p/>
   *  The move version bean has 2 alternative field value pairs:
   *  <dl>
   *  <dt>position</dt><dd>An absolute position, which may have a value of 'First', 'Last', 'Earlier' or 'Later'</dd>
   *  <dt>after</dt><dd>A version to place this version after.  The value should be the self link of another version</dd>
   *  </dl>
   */
  moveVersion: {
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a bean containing the number of fixed in and affected issues for the given version. */
  getVersionRelatedIssues: {
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the number of unresolved issues for the given version */
  getVersionUnresolvedIssues: {
    parameters: {
      path: {
        /** @description a String containing the version id */
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the remote version links associated with the given version ID. */
  getRemoteVersionLinksByVersionId: {
    parameters: {
      path: {
        /** @description The version for which to delete ALL existing remote version links */
        versionId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Create a remote version link via POST.  The link's global ID will be taken from the
   *  JSON payload if provided; otherwise, it will be generated.
   */
  createOrUpdateRemoteVersionLink: {
    parameters: {
      path: {
        /** @description The version ID of the remote link */
        versionId: string;
        /** @description The global ID of the remote link */
        globalId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete all remote version links for a given version ID. */
  deleteRemoteVersionLinksByVersionId: {
    parameters: {
      path: {
        /** @description The version for which to delete ALL existing remote version links */
        versionId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description A REST sub-resource representing a remote version link */
  getRemoteVersionLink: {
    parameters: {
      path: {
        /** @description The version ID of the remote link */
        versionId: string;
        /** @description The global ID of the remote link */
        globalId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete a specific remote version link with the given version ID and global ID. */
  deleteRemoteVersionLink: {
    parameters: {
      path: {
        /** @description The version ID of the remote link */
        versionId: string;
        /** @description The global ID of the remote link */
        globalId: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns all workflows. The lastModifiedDate is returned in Jira Complete Date/Time Format (dd/MMM/yy h:mm by default),
   *  but can also be returned as a relative date.
   */
  getAllWorkflows: {
    parameters: {
      query?: {
        workflowName?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Return the property or properties associated with a transition. */
  getProperties: {
    parameters: {
      query?: {
        /**
         * @description some keys under the "jira." prefix are editable, some are not. Set this to true
         *                             in order to include the non-editable keys in the response.
         */
        includeReservedKeys?: boolean;
        /** @description the name of the property key to query. Can be left off the query to return all properties. */
        key?: string;
        /** @description the name of the workflow to use. */
        workflowName?: string;
        /** @description the type of workflow to use. Can either be "live" or "draft". */
        workflowMode?: string;
      };
      path: {
        /** @description the ID of the transition within the workflow. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Update/add new property to a transition. Trying to update a property that does
   *  not exist will result in a new property being added.
   */
  updateProperty: {
    parameters: {
      query?: {
        /** @description the name of the property to add. */
        key?: string;
        /** @description the name of the workflow to use. */
        workflowName?: string;
        /** @description the type of workflow to use. Can either be "live" or "draft". */
        workflowMode?: string;
      };
      path: {
        /** @description the ID of the transition within the workflow. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Add a new property to a transition. Trying to add a property that already
   *  exists will fail.
   */
  createProperty: {
    parameters: {
      query?: {
        /** @description the name of the property to add. */
        key?: string;
        /** @description the name of the workflow to use. */
        workflowName?: string;
        /** @description the type of workflow to use. Can either be "live" or "draft". */
        workflowMode?: string;
      };
      path: {
        /** @description the ID of the transition within the workflow. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Create a new workflow scheme.
   *  <p/>
   *  The body contains a representation of the new scheme. Values not passed are assumed to be set to their defaults.
   */
  createScheme: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the requested workflow scheme to the caller. */
  getById: {
    parameters: {
      query?: {
        /**
         * @description when true indicates that a scheme's draft, if it exists, should be queried instead of
         *                             the scheme itself.
         */
        returnDraftIfExists?: boolean;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Update the passed workflow scheme.
   *  <p/>
   *  The body of the request is a representation of the workflow scheme. Values not passed are assumed to indicate
   *  no change for that field.
   *  <p/>
   *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft
   *  should be created and/or updated when the actual scheme cannot be edited (e.g. when the scheme is being used by
   *  a project). Values not appearing the body will not be touched.
   */
  update: {
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the passed workflow scheme. */
  deleteScheme: {
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Create a draft for the passed scheme. The draft will be a copy of the state of the parent. */
  createDraftForParent: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Return the default workflow from the passed workflow scheme. */
  getDefault: {
    parameters: {
      query?: {
        /**
         * @description when true indicates that a scheme's draft, if it exists, should be queried instead of
         *                             the scheme itself.
         */
        returnDraftIfExists?: boolean;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Set the default workflow for the passed workflow scheme.
   *  <p/>
   *  The passed representation can have its
   *  updateDraftIfNeeded flag set to true to indicate that the draft should be created/updated when the actual scheme
   *  cannot be edited.
   */
  updateDefault: {
    parameters: {
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove the default workflow from the passed workflow scheme. */
  deleteDefault: {
    parameters: {
      query?: {
        /**
         * @description when true will create and return a draft when the workflow scheme cannot be edited
         *                             (e.g. when it is being used by a project).
         */
        updateDraftIfNeeded?: boolean;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the requested draft workflow scheme to the caller. */
  getDraftById: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Update a draft workflow scheme. The draft will created if necessary.
   *  <p/>
   *  The body is a representation of the workflow scheme. Values not passed are assumed to indicate no change for that field.
   */
  updateDraft: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the passed draft workflow scheme. */
  deleteDraftById: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Return the default workflow from the passed draft workflow scheme to the caller. */
  getDraftDefault: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Set the default workflow for the passed draft workflow scheme. */
  updateDraftDefault: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove the default workflow from the passed draft workflow scheme. */
  deleteDraftDefault: {
    parameters: {
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the issue type mapping for the passed draft workflow scheme. */
  getDraftIssueType: {
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Set the issue type mapping for the passed draft scheme.
   *  <p/>
   *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that
   *  the draft should be created/updated when the actual scheme cannot be edited.
   */
  setDraftIssueType: {
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Remove the specified issue type mapping from the draft scheme. */
  deleteDraftIssueType: {
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the draft workflow mappings or requested mapping to the caller. */
  getDraftWorkflow: {
    parameters: {
      query?: {
        /** @description the workflow mapping to return. Null can be passed to return all mappings. Must be a valid workflow name. */
        workflowName?: string;
      };
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Update the draft scheme to include the passed mapping.
   *  <p/>
   *  The body is a representation of the workflow mapping.
   *  Values not passed are assumed to indicate no change for that field.
   */
  updateDraftWorkflowMapping: {
    parameters: {
      query?: {
        /** @description the name of the workflow mapping to update. */
        workflowName?: string;
      };
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the passed workflow from the draft workflow scheme. */
  deleteDraftWorkflowMapping: {
    parameters: {
      query?: {
        /** @description the name of the workflow to delete. */
        workflowName?: string;
      };
      path: {
        /** @description the id of the parent scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Set the issue type mapping for the passed scheme.
   *  <p/>
   *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that
   *  the draft should be created/updated when the actual scheme cannot be edited.
   */
  setIssueType: {
    parameters: {
      path: {
        /** @description the issue type being set. */
        issueType: string;
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Returns the workflow mappings or requested mapping to the caller for the passed scheme. */
  getWorkflow: {
    parameters: {
      query?: {
        /** @description the workflow mapping to return. Null can be passed to return all mappings. Must be a valid workflow name. */
        workflowName?: string;
        /**
         * @description when true indicates that a scheme's draft, if it exists, should be queried instead of
         *                             the scheme itself.
         */
        returnDraftIfExists?: boolean;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Update the scheme to include the passed mapping.
   *  <p/>
   *  The body is a representation of the workflow mapping.
   *  Values not passed are assumed to indicate no change for that field.
   *  <p/>
   *  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft
   *  should be created/updated when the actual scheme cannot be edited.
   */
  updateWorkflowMapping: {
    parameters: {
      query?: {
        /** @description the name of the workflow mapping to update. */
        workflowName?: string;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Delete the passed workflow from the workflow scheme. */
  deleteWorkflowMapping: {
    parameters: {
      query?: {
        /** @description the name of the workflow to delete. */
        workflowName?: string;
        /**
         * @description flag to indicate if a draft should be created if necessary to delete the workflow
         *                             from the scheme.
         */
        updateDraftIfNeeded?: boolean;
      };
      path: {
        /** @description the id of the scheme. */
        id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns worklogs id and delete time of worklogs that was deleted since given time.
   *  The returns set of worklogs is limited to 1000 elements.
   *  This API will not return worklogs deleted during last minute.
   */
  getIdsOfWorklogsDeletedSince: {
    parameters: {
      query?: {
        /** @description a date time in unix timestamp format since when deleted worklogs will be returned. */
        since?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns worklogs for given worklog ids. Only worklogs to which the calling user has permissions, will be included in the result.
   *  The returns set of worklogs is limited to 1000 elements.
   */
  getWorklogsForIds: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns worklogs id and update time of worklogs that was updated since given time.
   *  The returns set of worklogs is limited to 1000 elements.
   *  This API will not return worklogs updated during last minute.
   */
  getIdsOfWorklogsModifiedSince: {
    parameters: {
      query?: {
        /** @description a date time in unix timestamp format since when updated worklogs will be returned. */
        since?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Returns information about the currently authenticated user's session. If the caller is not authenticated they
   *  will get a 401 Unauthorized status code.
   */
  currentUser: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Creates a new session for a user in Jira. Once a session has been successfully created it can be used to access
   *  any of Jira's remote APIs and also the web UI by passing the appropriate HTTP Cookie header.
   *  <p>
   *  Note that it is generally preferrable to use HTTP BASIC authentication with the REST API. However, this resource
   *  may be used to mimic the behaviour of Jira's log-in page (e.g. to display log-in errors to a user).
   */
  login: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description Logs the current user out of Jira, destroying the existing session, if any. */
  logout: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
  /** @description This method invalidates the any current WebSudo session. */
  release: {
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
    };
  };
}
